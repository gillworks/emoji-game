<!DOCTYPE html>
<html>
  <head>
    <title>Emoji Adventure</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config.js"></script>
    <link rel="stylesheet" href="styles.css?v=25" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <script>
      // Add this line at the start of the first <script> section, before any gameState access
      let gameState = {};

      function getEnvVariable(name) {
        if (window.env && window.env[name]) {
          return window.env[name];
        }
        console.error(`Environment variable ${name} not found`);
        return null;
      }

      // Initialize Supabase client
      const supabaseClient = supabase.createClient(
        getEnvVariable("NEXT_PUBLIC_SUPABASE_URL"),
        getEnvVariable("NEXT_PUBLIC_SUPABASE_ANON_KEY")
      );

      function getUrlParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
      }

      let isDemoMode = getUrlParameter("mode") === "demo";

      gameState.inventory = {
        items: {},
        stacks: {},
      };

      // Add this near the top with other utility functions
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Add this before the debouncedUseItem function
      function showCollectionMessage(message) {
        const messageElement = document.createElement("div");
        messageElement.className = "collection-message";
        messageElement.textContent = message;
        document.getElementById("game-container").appendChild(messageElement);

        // Animate and remove the message
        setTimeout(() => {
          messageElement.remove();
        }, 2000);
      }

      // Update the useItem function to be debounced
      const debouncedUseItem = debounce(async function() {
        if (!gameState.playerPos || gameState.inBattle) return;

        const selectedSlot = gameState.inventory.selectedSlot;
        if (!selectedSlot) return;

        try {
          const { data, error } = await supabaseClient.rpc(
            "handle_item_action",
            {
              p_player_id: gameState.playerId,
              p_item_slot: selectedSlot,
              p_x: gameState.playerPos.x,
              p_y: gameState.playerPos.y,
              p_server_id: gameState.serverId,
            }
          );

          if (error) throw error;

          if (data.success) {
            showCollectionMessage(data.message);
            await loadInventory();
            renderMap();
          }
        } catch (error) {
          console.error("Error in useItem:", error);
        }
      }, 250); // 250ms debounce time

      function handleHotbarSelection(e) {
        // Handle both number row keys and numpad keys
        const key = e.key;
        if (!gameState.inBattle && key >= "0" && key <= "9") {
          // Convert key '0' to slot 10, otherwise use the number directly
          const slotNumber = key === "0" ? 10 : parseInt(key);

          // Remove selected class from all slots
          document.querySelectorAll(".hotbar-slot").forEach((slot) => {
            slot.classList.remove("selected");
          });

          // Add selected class to the clicked slot
          const selectedSlot = document.querySelector(
            `.hotbar-slot[data-slot="${slotNumber}"]`
          );
          if (selectedSlot) {
            selectedSlot.classList.add("selected");
            gameState.inventory.selectedSlot = slotNumber;
            debouncedUseItem();
          }
        }
      }

      document.addEventListener("keydown", handleHotbarSelection);

      // Select the first slot by default
      document.addEventListener("DOMContentLoaded", () => {
        document
          .querySelector('.hotbar-slot[data-slot="1"]')
          .classList.add("selected");
      });

      function updateHotbarDisplay() {
        // Update each slot with its item
        for (let slot = 1; slot <= 10; slot++) {
          const slotElement = document.querySelector(
            `.hotbar-slot[data-slot="${slot}"] .slot-content`
          );
          if (slotElement) {
            const item = gameState.inventory.items[slot] || "";
            const stack = gameState.inventory.stacks[slot];
            const currentStack = slotElement.getAttribute('data-stack');
            
            // Only update if content has actually changed
            if (slotElement.textContent !== item || 
                (currentStack !== (stack ? stack.toString() : null))) {
              
              // Use requestAnimationFrame for smooth updates
              requestAnimationFrame(() => {
                slotElement.textContent = item;
                
                // Update stack count
                if (stack) {
                  slotElement.setAttribute("data-stack", stack);
                } else {
                  slotElement.removeAttribute("data-stack");
                }
              });
            }
          }
        }
      }

      updateHotbarDisplay();

      // Add click handler for hotbar slots
      document.querySelectorAll(".hotbar-slot").forEach((slot) => {
        slot.addEventListener("click", () => {
          const slotNumber = parseInt(slot.dataset.slot);

          // Remove selected class from all slots
          document.querySelectorAll(".hotbar-slot").forEach((s) => {
            s.classList.remove("selected");
          });

          // Add selected class to clicked slot
          slot.classList.add("selected");
          gameState.inventory.selectedSlot = slotNumber;
          debouncedUseItem();
        });
      });

      function handleEmojiSelect(emoji) {
        // Update the player's emoji in the database
        supabaseClient
          .from("players")
          .update({ emoji: emoji })
          .eq("id", gameState.playerId)
          .then(({ error }) => {
            if (error) {
              console.error("Error updating player emoji:", error);
              return;
            }

            // Update the display
            document.querySelector("#player-emoji").textContent = emoji;
            gameState.playerEmoji = emoji;
            renderMap(); // Re-render to show new emoji on map
          });

        // Hide the emoji selector
        document.getElementById("emoji-selector").style.display = "none";
      }

      function toggleEmojiSelector() {
        const selector = document.getElementById("emoji-selector");
        selector.style.display =
          selector.style.display === "none" ? "grid" : "none";
      }

      // Modify the HTML for the player username section to include the emoji selector
      async function loadEmojiChoices() {
        try {
          const { data: emojiChoices, error } = await supabaseClient
            .from("emoji_choices")
            .select("*")
            .eq("enabled", true)
            .order("id");

          if (error) throw error;

          // Get the emoji selector container
          const selectorContainer = document.getElementById("emoji-selector");
          selectorContainer.innerHTML = ""; // Clear existing choices

          // Add each emoji choice
          emojiChoices.forEach((choice) => {
            const emojiOption = document.createElement("div");
            emojiOption.className = "emoji-option";
            emojiOption.onclick = () => handleEmojiSelect(choice.emoji);
            emojiOption.title = choice.name;
            emojiOption.textContent = choice.emoji;
            selectorContainer.appendChild(emojiOption);
          });
        } catch (error) {
          console.error("Error loading emoji choices:", error);
        }
      }

      // Replace the emoji selector HTML with a simpler container
    </script>
  </head>
  <body>
    <div id="auth-screen">
      <div class="auth-form">
        <h2 id="auth-title">Login</h2>
        <div id="auth-error" class="auth-error"></div>
        <form id="auth-form" onsubmit="handleAuth(event)">
          <input type="email" id="auth-email" placeholder="Email" />
          <input type="password" id="auth-password" placeholder="Password" />
          <button type="submit">Submit</button>
          <p>
            <span
              id="auth-toggle"
              class="auth-toggle"
              onclick="toggleAuthMode()"
            >
              Create an account instead
            </span>
          </p>
        </form>
      </div>
    </div>
    <div id="loading-screen">
      <div class="loading-emoji"></div>
      <div id="loading-message">Loading your adventure...</div>
    </div>
    <div id="game-container">
      <div id="status-bar">
        <div class="status-left">
          <div>HP: <span id="health">100</span></div>
          <div>XP: <span id="score">0</span></div>
        </div>
        <div class="status-right">
          <div>
            <span
              id="player-emoji"
              style="cursor: pointer"
              onclick="toggleEmojiSelector()"
              >üêª</span
            >
            <span id="player-username">-</span>
            <div id="emoji-selector" style="display: none"></div>
          </div>
          <div>
            <i
              class="fas fa-sign-out-alt logout-icon"
              onclick="handleLogout()"
              title="Logout"
            ></i>
          </div>
        </div>
      </div>

      <div id="game-layout">
        <div id="sidebar">
          <div class="sidebar-section">
            <h3>Current Location</h3>
            <div id="tile-info-panel">
              <div class="coordinates" title="Your current position on the map">
                x,y: (<span id="position-x">-</span>,<span id="position-y">-</span>)
              </div>
              <div class="hotbar-slot" data-slot="terrain">
                <div class="slot-content" id="tile-terrain"></div>
                <div class="slot-label">Terrain</div>
              </div>
              <div class="hotbar-slot" data-slot="resources">
                <div class="slot-content" id="tile-resources"></div>
                <div class="slot-label">Resources</div>
              </div>
              <div class="hotbar-slot" data-slot="actions">
                <div class="slot-content" id="tile-actions"></div>
                <div class="slot-label">E to interact</div>
              </div>
            </div>
          </div>
          <!-- Find the sidebar section and add this after the existing content -->
          <div class="sidebar-section" id="admin-controls" style="display: none;">
            <h3>Admin Controls</h3>
            <div class="toggle-container">
              <label class="toggle-switch">
                <input type="checkbox" id="encounter-toggle">
                <span class="toggle-slider"></span>
              </label>
              <span class="toggle-label">Random Encounters</span>
            </div>
          </div>
        </div>

        <div id="game-area">
          <div id="game-map">
            <canvas id="map-canvas"></canvas>
          </div>
          
          <div id="inventory-hotbar">
            <div class="hotbar-slot" data-slot="1" style="cursor: pointer">
              <div class="hotkey">1</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="2" style="cursor: pointer">
              <div class="hotkey">2</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="3" style="cursor: pointer">
              <div class="hotkey">3</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="4" style="cursor: pointer">
              <div class="hotkey">4</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="5" style="cursor: pointer">
              <div class="hotkey">5</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="6" style="cursor: pointer">
              <div class="hotkey">6</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="7" style="cursor: pointer">
              <div class="hotkey">7</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="8" style="cursor: pointer">
              <div class="hotkey">8</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="9" style="cursor: pointer">
              <div class="hotkey">9</div>
              <div class="slot-content"></div>
            </div>
            <div class="hotbar-slot" data-slot="10" style="cursor: pointer">
              <div class="hotkey">0</div>
              <div class="slot-content"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="battle-screen">
        <div class="battle-container">
          <div class="battle-fighter">
            <div class="fighter-emoji">üêª</div>
            <div class="hearts" id="player-hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
          </div>
          <div class="battle-moves" id="battle-moves"></div>
          <div class="battle-fighter">
            <div class="fighter-emoji" id="enemy-emoji"></div>
            <div class="hearts" id="enemy-hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
          </div>
        </div>
        <div id="battle-options">
          <button class="battle-option" onclick="chooseBattle('fight')">
            <span class="key-indicator">F</span>
            Fight
          </button>
          <button class="battle-option" onclick="chooseBattle('run')">
            <span class="key-indicator">R</span>
            Run
          </button>
        </div>
        <div id="attack-options" style="display: none">
          <button class="battle-option" onclick="chooseAttack('quick')">
            <span class="key-indicator">1</span>
            Quick Attack üå™Ô∏è
          </button>
          <button class="battle-option" onclick="chooseAttack('heavy')">
            <span class="key-indicator">2</span>
            Heavy Attack üî®
          </button>
          <button class="battle-option" onclick="chooseAttack('block')">
            <span class="key-indicator">3</span>
            Block üõ°Ô∏è
          </button>
        </div>
      </div>

      <div id="game-over">
        <h1>Game Over!</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-button" onclick="restartGame()">Play Again</button>
      </div>

      <!-- Add this before </body> -->
      <div id="crafting-modal" class="modal">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Crafting</h2>
            <span class="close-button" onclick="closeCraftingMenu()"
              >&times;</span
            >
          </div>
          <div id="crafting-panel">
            <div id="available-recipes"></div>
            <div id="recipe-details"></div>
            <button
              id="craft-button"
              onclick="craftSelectedRecipe()"
              style="display: none"
            >
              Craft
            </button>
          </div>
        </div>
      </div>

      <!-- Add this before </body> -->
      <div id="build-modal" class="modal">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Build Structure</h2>
            <span class="close-button" onclick="closeBuildMenu()">&times;</span>
          </div>
          <div id="build-panel">
            <div id="available-structures"></div>
            <div id="structure-details"></div>
            <button id="build-button" onclick="buildSelectedStructure()" style="display: none">
              Build (B)
            </button>
          </div>
        </div>
      </div>

      <!-- Update the storage modal HTML -->
      <div id="storage-modal" class="modal">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Storage Chest</h2>
            <span class="close-button" onclick="closeStorageMenu()">&times;</span>
          </div>
          <div id="storage-panel">
            <div class="inventory-container">
              <div class="inventory-section">
                <h3>Storage</h3>
                <div class="storage-grid">
                  <!-- Storage slots will be generated dynamically -->
                </div>
              </div>
              <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div class="player-inventory-grid">
                  <!-- Player inventory slots will be generated here -->
                </div>
              </div>
            </div>
            <div class="storage-controls">
              <button id="transfer-button" onclick="executeStorageAction()" disabled>
                Transfer Item (X)
              </button>
            </div>
          </div>
        </div>
      </div>

      <script>
        let TERRAIN_TYPES = {};

        // Replace the loadTerrainTypes function with:
        async function loadTerrainTypes() {
          try {
            const { data, error } = await supabaseClient
              .from("terrain_types")
              .select("*");

            if (error) throw error;
            if (!data || data.length === 0)
              throw new Error("No terrain types found");

            // Convert array to object format
            TERRAIN_TYPES = data.reduce((acc, terrain) => {
              acc[terrain.id] = {
                emoji: terrain.emoji,
                encounter: terrain.encounter,
                color: terrain.color,
              };
              return acc;
            }, {});

          } catch (error) {
            console.error("Error loading terrain types:", error);
            throw error; // Re-throw to be handled by initGame
          }
        }

        gameState = {
          map: [],
          playerPos: null,
          health: 100,
          score: 0,
          inBattle: false,
          currentEnemy: null,
          playerHits: 0,
          enemyHits: 0,
          viewport: {
            x: 0,
            y: 0,
            scale: 1,
            isDragging: false,
            lastX: 0,
            lastY: 0,
            cellSizeMultiplier: isDemoMode ? 0.085 : 0.04,
          },
          playerId: null,
          otherPlayers: new Map(),
          configs: null,
          serverId: null,
          mapWidth: 20,
          mapHeight: 20,
          playerAnimation: {
            bounceOffset: 0,
          },
          inventory: {
            items: {},
            stacks: {},
          },
          crafting: {
            isOpen: false,
            selectedRecipeIndex: -1,
            recipes: [],
          },
          building: {
            isOpen: false,
            selectedStructureIndex: -1,
            structures: []
          },
          currentResource: null,
          resourceChannel: null, 
        };

        let lastActiveInterval;

        function startLastActiveUpdates() {
          if (lastActiveInterval) {
            clearInterval(lastActiveInterval);
          }

          lastActiveInterval = setInterval(async () => {
            if (gameState.serverId) {
              try {
                await supabaseClient.rpc("increment_server_players", {
                  server_id: gameState.serverId,
                });
              } catch (error) {
                console.error("Error updating last_active:", error);
              }
            }
          }, 30000);
        }

        async function fetchGameConfigs() {
          try {
            const { data, error } = await supabaseClient
              .from("game_configs")
              .select("*");

            if (error) throw error;

            // Convert array of configs to object
            const configs = {};
            data.forEach((config) => {
              configs[config.key] = config.value;
            });

            gameState.configs = configs;
          } catch (error) {
            console.error("Error fetching game configs:", error);
            // Use default values if configs can't be loaded
            gameState.configs = {
              encounter_rates: {
                FOREST: 0.3,
                MOUNTAIN: 0.4,
                PLAIN: 0.2,
                OCEAN: 0.3,
              },
            };
          }
        }

        async function findOrCreateServer() {
          try {
            // First check if player is already in a server using two separate queries
            const { data: playerServers, error: playerError } =
              await supabaseClient
                .from("server_players")
                .select("server_id")
                .eq("player_id", gameState.playerId);

            if (!playerError && playerServers && playerServers.length > 0) {
              const playerServer = playerServers[0];
              // Get server details
              const { data: serverDetails, error: serverError } =
                await supabaseClient
                  .from("servers")
                  .select("*")
                  .eq("id", playerServer.server_id)
                  .single();

              if (
                !serverError &&
                serverDetails &&
                serverDetails.status === "active"
              ) {

                // Call increment_server_players to ensure count is correct
                await supabaseClient.rpc("increment_server_players", {
                  server_id: playerServer.server_id,
                });

                gameState.serverId = playerServer.server_id;
                return playerServer.server_id;
              } else {
                // Server is inactive or doesn't exist, remove player from it
                await supabaseClient.from("server_players").delete().match({
                  server_id: playerServer.server_id,
                  player_id: gameState.playerId,
                });
              }
            }

            // Rest of the function remains the same
            const { data: servers, error: serverError } = await supabaseClient
              .from("servers")
              .select(
                `
                *,
                player_count:server_players(count)
              `
              )
              .eq("status", "active")
              .limit(1);

            if (serverError) throw serverError;

            let serverId;

            if (servers && servers.length > 0) {
              const server = servers[0];
              const playerCount = server.player_count[0].count;

              if (playerCount < server.max_players) {
                // Join existing server
                serverId = server.id;
              }
            } else {
              // Create new server
              const { data: newServer, error: createError } = await supabaseClient
                .from("servers")
                .insert([
                  {
                    name: `Server ${Math.floor(Math.random() * 1000)}`,
                    status: "active",
                    max_players: 100,
                  },
                ])
                .select()
                .single();

              if (createError) throw createError;
              serverId = newServer.id;

              // Generate and store map for new server
              await generateAndStoreMap(serverId);
            }

            // Join server
            const { error: joinError } = await supabaseClient
              .from("server_players")
              .upsert([
                {
                  server_id: serverId,
                  player_id: gameState.playerId,
                },
              ]);

            if (joinError) throw joinError;

            // Always call increment_server_players after joining
            await supabaseClient.rpc("increment_server_players", {
              server_id: serverId,
            });

            gameState.serverId = serverId;
            return serverId;
          } catch (error) {
            console.error("Error finding/creating server:", error);
            throw error;
          }
        }

        async function loadMap(serverId) {
          try {
            // Get the server's map dimensions
            const { data: serverData, error: serverError } = await supabaseClient
              .from("servers")
              .select("map_width, map_height")
              .eq("id", serverId)
              .single();

            if (serverError) throw serverError;

            // Update gameState with the server's map dimensions
            gameState.mapWidth = serverData.map_width || 20;
            gameState.mapHeight = serverData.map_height || 20;

            // Initialize empty map with correct dimensions
            gameState.map = Array(gameState.mapHeight)
              .fill()
              .map(() => Array(gameState.mapWidth).fill(TERRAIN_TYPES.PLAIN));

            // Calculate total tiles needed
            const totalTiles = gameState.mapWidth * gameState.mapHeight;
            const pageSize = 1000;
            const totalPages = Math.ceil(totalTiles / pageSize);

            // Load map data in pages
            for (let page = 0; page < totalPages; page++) {
              const { data: mapData, error } = await supabaseClient
                .from("map_data")
                .select("x, y, terrain_type")
                .eq("server_id", serverId)
                .range(page * pageSize, (page + 1) * pageSize - 1);

              if (error) {
                console.error(`Error loading page ${page}:`, error);
                throw error;
              }

              // Populate map from database
              mapData.forEach((tile) => {
                if (
                  tile.x >= 0 &&
                  tile.x < gameState.mapWidth &&
                  tile.y >= 0 &&
                  tile.y < gameState.mapHeight &&
                  TERRAIN_TYPES[tile.terrain_type]
                ) {
                  gameState.map[tile.y][tile.x] =
                    TERRAIN_TYPES[tile.terrain_type];
                }
              });
            }

            // After map is fully loaded
            renderMap();
            updateTileInfo();
          } catch (error) {
            console.error("Error loading map:", error);
            throw error;
          }
        }

        async function generateAndStoreMap(serverId) {
          try {
            // Get the server's map dimensions
            const { data: serverData, error: serverError } = await supabaseClient
              .from("servers")
              .select("map_width, map_height")
              .eq("id", serverId)
              .single();

            if (serverError) throw serverError;

            const mapWidth = serverData.map_width || 20;
            const mapHeight = serverData.map_height || 20;

            const mapData = [];
            let debug_counts = {
              FOREST: 0,
              MOUNTAIN: 0,
              PLAIN: 0,
              OCEAN: 0,
            };

            for (let y = 0; y < mapHeight; y++) {
              for (let x = 0; x < mapWidth; x++) {
                const rand = Math.random();
                let terrainType;

                if (rand < 0.25) {
                  terrainType = "FOREST";
                  debug_counts.FOREST++;
                } else if (rand < 0.5) {
                  terrainType = "MOUNTAIN";
                  debug_counts.MOUNTAIN++;
                } else if (rand < 0.75) {
                  terrainType = "PLAIN";
                  debug_counts.PLAIN++;
                } else {
                  terrainType = "OCEAN";
                  debug_counts.OCEAN++;
                }

                mapData.push({
                  server_id: serverId,
                  x: x,
                  y: y,
                  terrain_type: terrainType,
                });
              }
            }

            // Insert in batches of 1000 to avoid payload size limits
            for (let i = 0; i < mapData.length; i += 1000) {
              const batch = mapData.slice(i, i + 1000);
              const { error } = await supabaseClient
                .from("map_data")
                .insert(batch);

              if (error) {
                console.error("Error inserting batch:", error);
                throw error;
              }
            }

            // Verify the data was inserted correctly
            const { data: verifyData, error: verifyError } = await supabaseClient
              .from("map_data")
              .select("terrain_type")
              .eq("server_id", serverId)
              .limit(5);

            if (verifyError) {
              console.error("Error verifying map data:", verifyError);
            }
          } catch (error) {
            console.error("Error storing map:", error);
            throw error;
          }
        }

        let isRegistering = false;

        async function initSupabase() {
          try {

            // Add retry mechanism for getting session
            let session;
            let retries = 3;
            while (retries > 0) {
              const { data: sessionData, error: sessionError } =
                await supabaseClient.auth.getSession();

              if (sessionError) {
                console.error("Session error:", sessionError);
                throw sessionError;
              }

              if (sessionData?.session?.access_token) {
                session = sessionData.session;
                break;
              }

              console.log(`Waiting for session... (${retries} retries left)`);
              await new Promise((resolve) => setTimeout(resolve, 500));
              retries--;
            }

            if (!session) {
              console.log("No session, showing login/signup form...");
              showAuthScreen();
              return false;
            }

            // Add small delay after getting session
            await new Promise((resolve) => setTimeout(resolve, 500));

            const {
              data: { user },
              error: userError,
            } = await supabaseClient.auth.getUser();

            if (userError) {
              console.error("Get user error:", userError);
              throw userError;
            }

            gameState.playerId = user.id;

            // Create player record if it doesn't exist
            console.log("Creating player record...");
            const { error: playerError } = await supabaseClient
              .from("players")
              .upsert({
                id: gameState.playerId,
                username: user.email.split("@")[0],
                created_at: new Date().toISOString(),
              });

            if (playerError) {
              console.error("Player creation error:", playerError);
              throw playerError;
            }

            // Find or create server BEFORE handling positions
            const serverId = await findOrCreateServer();
            gameState.serverId = serverId;

            return true;
          } catch (error) {
            console.error("Error initializing Supabase:", error);
            showAuthScreen();
            return false;
          }
        }

        function showAuthScreen() {
          document.getElementById("auth-screen").style.display = "flex";
          document.getElementById("game-container").style.display = "none";
        }

        function hideAuthScreen() {
          document.getElementById("auth-screen").style.display = "none";
          document.getElementById("game-container").style.display = "flex";
        }

        function toggleAuthMode() {
          isRegistering = !isRegistering;
          const title = document.getElementById("auth-title");
          const toggle = document.getElementById("auth-toggle");
          const error = document.getElementById("auth-error");
          const submitButton = document.querySelector(
            '.auth-form button[type="submit"]'
          );

          title.textContent = isRegistering ? "Create Account" : "Login";
          toggle.textContent = isRegistering
            ? "Login instead"
            : "Create an account instead";
          error.style.display = "none";

          // Reset button state
          submitButton.disabled = false;
          submitButton.textContent = "Submit";

          // Clear the form
          document.getElementById("auth-form").reset();
        }

        function validateCredentials(email, password) {
          const errorDiv = document.getElementById("auth-error");

          if (!email || !password) {
            errorDiv.style.color = "#ff6b6b";
            errorDiv.style.display = "block";
            errorDiv.textContent = "Email and password are required";
            return false;
          }

          if (password.length < 6) {
            errorDiv.style.color = "#ff6b6b";
            errorDiv.style.display = "block";
            errorDiv.textContent = "Password must be at least 6 characters long";
            return false;
          }

          if (!email.includes("@")) {
            errorDiv.style.color = "#ff6b6b";
            errorDiv.style.display = "block";
            errorDiv.textContent = "Please enter a valid email address";
            return false;
          }

          return true;
        }

        async function handleAuth(event) {
          event.preventDefault();

          const email = document.getElementById("auth-email").value;
          const password = document.getElementById("auth-password").value;

          if (!validateCredentials(email, password)) {
            return;
          }

          const errorDiv = document.getElementById("auth-error");
          const submitButton = document.querySelector(
            '.auth-form button[type="submit"]'
          );
          const authTitle = document.getElementById("auth-title");
          const authToggle = document.getElementById("auth-toggle");
          const authForm = document.getElementById("auth-form");

          // Disable the submit button and show loading state
          submitButton.disabled = true;
          submitButton.textContent = "Loading...";
          errorDiv.style.display = "none";

          try {
            if (isRegistering) {
              const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
              });

              if (error) throw error;
              if (!data?.user)
                throw new Error("Registration failed - no user data returned");

              // Hide the entire form including input fields
              authForm.style.display = "none";
              authToggle.style.display = "none";

              // Update title
              authTitle.textContent = "Check Your Email";

              // Show confirmation message
              errorDiv.style.display = "block";
              errorDiv.style.color = "#4caf50"; // Green color for success
              errorDiv.innerHTML = `
                  ‚úâÔ∏è Registration successful!<br><br>
                  We've sent a confirmation link to:<br>
                  <strong>${email}</strong><br><br>
                  Please check your email and click the confirmation link to activate your account.<br><br>
                  <button onclick="switchToLogin()" class="auth-form-button">Return to Login</button>
              `;

              return;
            } else {
              const { data, error } =
                await supabaseClient.auth.signInWithPassword({
                  email,
                  password,
                });

              if (error) {
                if (error.message === "Invalid login credentials") {
                  throw new Error("Invalid email or password. Please try again.");
                }
                throw error;
              }

              if (!data?.session) {
                throw new Error("Login failed - no session created");
              }

              hideAuthScreen();
              initGame();
            }
          } catch (error) {
            console.error("Auth error:", error);
            errorDiv.style.color = "#ff6b6b";
            errorDiv.style.display = "block";
            errorDiv.textContent =
              error.message || "An error occurred during authentication";
          } finally {
            if (!isRegistering) {
              // Only reset button if not in registration success state
              submitButton.disabled = false;
              submitButton.textContent = "Submit";
            }
          }
        }

        // Update the switchToLogin function to show the form again
        function switchToLogin() {
          isRegistering = false;
          const authTitle = document.getElementById("auth-title");
          const authToggle = document.getElementById("auth-toggle");
          const submitButton = document.querySelector(
            '.auth-form button[type="submit"]'
          );
          const errorDiv = document.getElementById("auth-error");
          const authForm = document.getElementById("auth-form");

          // Show the form again
          authForm.style.display = "block";

          // Reset the form display
          authTitle.textContent = "Login";
          authToggle.style.display = "block";
          authToggle.textContent = "Create an account instead";
          submitButton.style.display = "block";
          submitButton.disabled = false;
          submitButton.textContent = "Submit";
          errorDiv.style.display = "none";

          // Clear any input values
          authForm.reset();
        }

        function renderMap() {
          const canvas = document.getElementById("map-canvas");
          const ctx = canvas.getContext("2d");
          const cellSize =
            Math.min(window.innerWidth, window.innerHeight) *
            gameState.viewport.cellSizeMultiplier;

          // Reset any transformations
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          // Set canvas size using width and height
          canvas.width = gameState.mapWidth * cellSize;
          canvas.height = gameState.mapHeight * cellSize;

          // Clear canvas with a background color
          ctx.fillStyle = "#2a2a2a";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw terrain backgrounds and emojis
          for (let y = 0; y < gameState.mapHeight; y++) {
            for (let x = 0; x < gameState.mapWidth; x++) {
              const terrain = gameState.map[y][x];
              if (!terrain || !terrain.emoji) continue;

              // Draw background color
              ctx.fillStyle = terrain.color;
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

              // Draw terrain emoji with larger size
              ctx.font = `${cellSize * 0.9}px Arial`;
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillStyle = "white";
              ctx.fillText(
                terrain.emoji,
                x * cellSize + cellSize / 2,
                y * cellSize + cellSize / 2
              );
            }
          }

          // Draw other players with their emojis
          ctx.font = `${cellSize * 0.9}px Arial`;
          gameState.otherPlayers.forEach((pos) => {
            ctx.fillText(
              pos.emoji || "üêª", // Use bear as fallback
              pos.x * cellSize + cellSize / 2,
              pos.y * cellSize + cellSize / 2
            );
          });

          // Draw main player with larger size
          if (gameState.playerPos) {
            ctx.font = `${cellSize * 0.9}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "white";
            ctx.fillText(
              gameState.playerEmoji || "üêª",
              gameState.playerPos.x * cellSize + cellSize / 2,
              gameState.playerPos.y * cellSize +
                cellSize / 2 +
                gameState.playerAnimation.bounceOffset
            );
          }

          // Apply viewport transform
          canvas.style.transform = `translate(${gameState.viewport.x}px, ${gameState.viewport.y}px) scale(${gameState.viewport.scale})`;
        }

        function initCanvas() {
          const canvas = document.getElementById("map-canvas");
          const cellSize = Math.min(window.innerWidth, window.innerHeight) * 0.04;

          canvas.width = gameState.mapWidth * cellSize;
          canvas.height = gameState.mapHeight * cellSize;
        }

        function updateStatus() {
          document.getElementById("health").textContent = gameState.health;
          document.getElementById("score").textContent = gameState.score;
          if (gameState.playerPos) {
            document.getElementById("position-x").textContent =
              gameState.playerPos.x;
            document.getElementById("position-y").textContent =
              gameState.playerPos.y;
          }
        }

        // Add after the gameState declaration
        let isAdmin = false;

        // Add this function after initSupabase
        async function checkAdminStatus() {
          try {
            const { data, error } = await supabaseClient
              .from('admin_users')
              .select('id')
              .eq('id', gameState.playerId)
              .maybeSingle();

            if (error) throw error;
            
            isAdmin = !!data;
            
            // Show/hide admin controls
            const adminControls = document.getElementById('admin-controls');
            if (adminControls) {
              adminControls.style.display = isAdmin ? 'block' : 'none';
            }
          } catch (error) {
            console.error('Error checking admin status:', error);
          }
        }

        // Modify the checkEncounter function to respect the toggle
        function checkEncounter() {
          // Get toggle state if admin, otherwise default to true
          const encounterToggle = document.getElementById('encounter-toggle');
          const encountersEnabled = !isAdmin || (encounterToggle && encounterToggle.checked);
          
          if (!encountersEnabled) return;

          const currentTerrain = gameState.map[gameState.playerPos.y][gameState.playerPos.x];
          const terrainType = Object.keys(TERRAIN_TYPES).find(
            (type) => TERRAIN_TYPES[type].emoji === currentTerrain.emoji
          );

          const encounterRate = gameState.configs?.encounter_rates?.[terrainType] ?? 0.3;

          if (Math.random() < encounterRate) {
            gameState.inBattle = true;
            gameState.currentEnemy = currentTerrain.encounter;
            showBattleScreen();
          }
        }

        function showBattleScreen() {
          document.getElementById("battle-screen").style.display = "block";
          document.getElementById("enemy-emoji").textContent =
            gameState.currentEnemy;
          document.getElementById("battle-options").style.display = "block";
          document.getElementById("attack-options").style.display = "none";
          document.getElementById("battle-moves").innerHTML = "";

          // Update the player's emoji in battle screen
          document.querySelector(".battle-fighter .fighter-emoji").textContent =
            gameState.playerEmoji || "üêª";

          // Reset hearts
          document.getElementById("player-hearts").innerHTML = "‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è";
          document.getElementById("enemy-hearts").innerHTML = "‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è";
        }

        function chooseBattle(choice) {
          if (choice === "fight") {
            document.getElementById("battle-options").style.display = "none";
            document.getElementById("attack-options").style.display = "block";
            document.getElementById("battle-moves").innerHTML =
              "Choose your attack!";
          } else {
            // Disable battle options immediately to prevent multiple runs
            const battleOptions = document.querySelectorAll(".battle-option");
            battleOptions.forEach((button) => (button.disabled = true));

            if (Math.random() < 0.6) {
              // Successful escape
              gameState.inBattle = false; // Set this immediately to prevent further battle actions
              const battleMoves = document.getElementById("battle-moves");
              battleMoves.innerHTML = "üèÉ Got away safely!";
              setTimeout(endBattle, 1500);
            } else {
              // Failed escape
              gameState.health -= 10;
              updateStatus();
              const battleMoves = document.getElementById("battle-moves");
              battleMoves.innerHTML = "üò∞ Couldn't escape! -10 health!";

              // Re-enable battle options only if escape failed
              battleOptions.forEach((button) => (button.disabled = false));

              if (gameState.health <= 0) {
                gameOver();
              }
            }
          }
        }

        function chooseAttack(playerChoice) {
          // Prevent attacks if battle is ending
          if (!gameState.inBattle) return;

          const choices = ["quick", "heavy", "block"];
          const enemyChoice = choices[Math.floor(Math.random() * choices.length)];

          const attackEmojis = {
            quick: "üå™Ô∏è",
            heavy: "üî®",
            block: "üõ°Ô∏è",
          };

          // Show the moves
          document.getElementById(
            "battle-moves"
          ).innerHTML = `${attackEmojis[playerChoice]} VS ${attackEmojis[enemyChoice]}`;

          let result = "";
          if (
            (playerChoice === "quick" && enemyChoice === "heavy") ||
            (playerChoice === "heavy" && enemyChoice === "block") ||
            (playerChoice === "block" && enemyChoice === "quick")
          ) {
            gameState.playerHits++;
            result = "‚ú®";
            // Update enemy hearts (ensure non-negative value)
            const hearts = document.getElementById("enemy-hearts");
            hearts.innerHTML = "‚ù§Ô∏è".repeat(Math.max(0, 3 - gameState.playerHits));
          } else if (playerChoice === enemyChoice) {
            result = "ü§úü§õ";
          } else {
            gameState.enemyHits++;
            result = "üí•";
            // Update player hearts (ensure non-negative value)
            const hearts = document.getElementById("player-hearts");
            hearts.innerHTML = "‚ù§Ô∏è".repeat(Math.max(0, 3 - gameState.enemyHits));
          }

          // Show hit animation
          const battleContainer = document.querySelector(".battle-container");
          const resultElement = document.createElement("div");
          resultElement.className = "attack-result";
          resultElement.textContent = result;
          resultElement.style.left = "50%";
          resultElement.style.top = "50%";
          battleContainer.appendChild(resultElement);

          // Remove the animation element after it completes
          setTimeout(() => {
            resultElement.remove();
          }, 1000);

          if (gameState.playerHits >= 3) {
            // Disable further attacks
            gameState.inBattle = false;
            // Disable attack buttons
            const attackButtons = document.querySelectorAll(".battle-option");
            attackButtons.forEach((button) => (button.disabled = true));

            gameState.score += 100;
            updateStatus();
            setTimeout(() => {
              showVictoryAnimation();
              setTimeout(endBattle, 1500);
            }, 1000);
          } else if (gameState.enemyHits >= 3) {
            // Disable further attacks
            gameState.inBattle = false;
            // Disable attack buttons
            const attackButtons = document.querySelectorAll(".battle-option");
            attackButtons.forEach((button) => (button.disabled = true));

            gameState.health -= 30;
            updateStatus();
            setTimeout(() => {
              showDefeatAnimation();
              setTimeout(endBattle, 1500);
            }, 1000);
          }

          if (gameState.health <= 0) {
            gameOver();
          }
        }

        function endBattle() {
          gameState.inBattle = false;
          gameState.currentEnemy = null;
          gameState.playerHits = 0;
          gameState.enemyHits = 0;

          // Re-enable all battle buttons
          const battleButtons = document.querySelectorAll(".battle-option");
          battleButtons.forEach((button) => (button.disabled = false));

          document.getElementById("battle-screen").style.display = "none";
        }

        function gameOver() {
          document.getElementById("game-over").style.display = "flex";
          document.getElementById("final-score").textContent = gameState.score;
        }

        function restartGame() {
          window.location.reload();
        }

        // Pan handling
        const gameMap = document.getElementById("game-map");

        gameMap.addEventListener("mousedown", (e) => {
          if (gameState.inBattle) return;
          gameState.viewport.isDragging = true;
          gameState.viewport.lastX = e.clientX;
          gameState.viewport.lastY = e.clientY;
          gameMap.style.cursor = "grabbing";
        });

        gameMap.addEventListener("mousemove", (e) => {
          if (!gameState.viewport.isDragging) return;

          const dx = e.clientX - gameState.viewport.lastX;
          const dy = e.clientY - gameState.viewport.lastY;

          gameState.viewport.x += dx;
          gameState.viewport.y += dy;

          gameState.viewport.lastX = e.clientX;
          gameState.viewport.lastY = e.clientY;

          renderMap();
        });

        gameMap.addEventListener("mouseup", () => {
          gameState.viewport.isDragging = false;
          gameMap.style.cursor = "grab";
        });

        gameMap.addEventListener("mouseleave", () => {
          gameState.viewport.isDragging = false;
          gameMap.style.cursor = "grab";
        });

        // Add this near the top of the file with other gameState initialization
        let selectedStorageSlot = null;

        // Update the keyboard event handler to check for open modals
        document.addEventListener("keydown", async (e) => {
          if (!e || !e.key) return;
          const key = e.key.toLowerCase();

          // Don't process movement if any modal is open
          if (document.querySelector('.modal.active')) {
            // Still handle ESC key for closing modals
            if (key === 'escape') {
              if (gameState.crafting.isOpen) closeCraftingMenu();
              if (gameState.building.isOpen) closeBuildMenu();
              closeStorageMenu();
            }
            return;
          }

          // Handle battle controls first if in battle
          if (gameState.inBattle) {
            switch (key) {
              case "f":
                chooseBattle('fight');
                return;
              case "r":
                chooseBattle('run');
                return;
              case "1":
                chooseAttack('quick');
                return;
              case "2":
                chooseAttack('heavy');
                return;
              case "3":
                chooseAttack('block');
                return;
            }
            return; // Don't process other keys during battle
          }

          // Handle build menu controls
          if (gameState.building.isOpen) {
            switch (key) {
              case "b":
                if (gameState.building.selectedStructureIndex !== -1) {
                  buildSelectedStructure();
                }
                e.preventDefault();
                return;
              case "escape":
                closeBuildMenu();
                e.preventDefault();
                return;
              case "arrowup":
                e.preventDefault();
                navigateStructures(-1);
                return;
              case "arrowdown":
                e.preventDefault();
                navigateStructures(1);
                return;
            }
            return; // Don't process other keys while build menu is open
          }

          // Handle crafting menu controls
          if (gameState.crafting.isOpen) {
            switch (key) {
              case "c":
                if (gameState.crafting.selectedRecipeIndex !== -1) {
                  craftSelectedRecipe();
                }
                e.preventDefault();
                return;
              case "escape":
                closeCraftingMenu();
                e.preventDefault();
                return;
              case "arrowup":
                e.preventDefault();
                navigateRecipes(-1);
                return;
              case "arrowdown":
                e.preventDefault();
                navigateRecipes(1);
                return;
            }
            return; // Don't process other keys while crafting is open
          }

          // Handle resource collection with E key - MOVED HERE
          if (key === 'e' && !gameState.inBattle) {
            await collectResource();
            e.preventDefault();
            return;
          }

          // Handle menu toggles
          if (key === "b") {
            openBuildMenu();
            e.preventDefault();
            return;
          }

          if (key === "c") {
            openCraftingMenu();
            e.preventDefault();
            return;
          }

          // Handle hotbar selection (1-9, 0)
          if (key >= "0" && key <= "9") {
            const slotNumber = key === "0" ? 10 : parseInt(key);
            document.querySelectorAll(".hotbar-slot").forEach((slot) => {
              slot.classList.remove("selected");
            });
            const selectedSlot = document.querySelector(
              `.hotbar-slot[data-slot="${slotNumber}"]`
            );
            if (selectedSlot) {
              selectedSlot.classList.add("selected");
              gameState.inventory.selectedSlot = slotNumber;
              debouncedUseItem();
            }
            return;
          }

          // Only process movement if player position exists
          if (!gameState.playerPos) return;

          // Movement controls
          const newPos = { ...gameState.playerPos };
          switch (key) {
            case "w":
            case "arrowup":
              if (newPos.y > 0) newPos.y--;
              break;
            case "s":
            case "arrowdown":
              if (newPos.y < gameState.mapHeight - 1) newPos.y++;
              break;
            case "a":
            case "arrowleft":
              if (newPos.x > 0) newPos.x--;
              break;
            case "d":
            case "arrowright":
              if (newPos.x < gameState.mapWidth - 1) newPos.x++;
              break;
            default:
              return;
          }

          // Update position in game state and database
          gameState.playerPos = newPos;
          try {
            const { error } = await supabaseClient
              .from("player_positions")
              .upsert({
                player_id: gameState.playerId,
                server_id: gameState.serverId,
                x: newPos.x,
                y: newPos.y,
              });

            if (error) throw error;
          } catch (error) {
            console.error("Error updating position:", error);
          }

          renderMap();
          updateStatus();
          checkEncounter();
          updateTileInfo();
        });

        // Modify initGame to wait for terrain types
        async function initGame() {
          try {
            // Load terrain types first
            await loadTerrainTypes();

            showLoadingScreen();

            const isAuthenticated = await initSupabase();
            if (!isAuthenticated) {
              hideLoadingScreen();
              return;
            }

            await fetchGameConfigs();
            await loadStructures();
            
            // Find or create server should be called before checking positions
            const serverId = await findOrCreateServer();
            gameState.serverId = serverId;

            // Add demo mode UI adjustments
            if (isDemoMode) {
              document.querySelector(
                "#status-bar div:nth-child(4)"
              ).style.display = "none";
              document.querySelector(
                "#status-bar div:nth-child(5)"
              ).style.display = "none";
            }

            // Get player username and update display
            const { data: playerData, error: playerError } = await supabaseClient
              .from("players")
              .select("username, emoji")
              .eq("id", gameState.playerId)
              .single();

            if (playerError) {
              console.error("Error fetching player data:", playerError);
              throw playerError;
            }

            // Set the player's emoji (use bear as default if none set)
            gameState.playerEmoji = playerData.emoji || "üêª";
            document.getElementById("player-emoji").textContent =
              gameState.playerEmoji;
            document.querySelector(".fighter-emoji").textContent =
              gameState.playerEmoji;

            // Load emoji choices here, after player data is set
            await loadEmojiChoices();

            if (!playerError && playerData) {
              document.getElementById("player-username").textContent =
                playerData.username;
            }

            await loadMap(gameState.serverId);
            await setupPlayerSubscriptions();

            // Create initial player position if none exists
            const { data: existingPos, error: posQueryError } =
              await supabaseClient
                .from("player_positions")
                .select("x, y")
                .match({
                  player_id: gameState.playerId,
                  server_id: gameState.serverId,
                })
                .maybeSingle();

            // Add detailed error logging
            if (posQueryError) {
              console.error("Position query error details:", {
                error: posQueryError,
                query: {
                  playerId: gameState.playerId,
                  serverId: gameState.serverId,
                },
              });
            }

            if (existingPos) {
              gameState.playerPos = existingPos;
            } else {
              // Set initial position to center of map
              const newPosition = {
                x: Math.floor(gameState.mapWidth / 2),
                y: Math.floor(gameState.mapHeight / 2),
              };

              // Insert new position
              const { data: newPos, error: posError } = await supabaseClient
                .from("player_positions")
                .insert([
                  {
                    player_id: gameState.playerId,
                    server_id: gameState.serverId,
                    x: newPosition.x,
                    y: newPosition.y,
                  },
                ])
                .select()
                .single();

              if (posError) {
                console.error("Error creating initial position:", posError);
                console.error("Attempted values:", {
                  player_id: gameState.playerId,
                  server_id: gameState.serverId,
                  x: newPosition.x,
                  y: newPosition.y,
                });
                throw posError;
              } else {
                gameState.playerPos = newPosition;
              }
            }

            updateTileInfo();

            // Load inventory after player is authenticated and server is set up
            await loadInventory();

            // Add inventory subscription
            supabaseClient
              .channel("inventory_changes")
              .on(
                "postgres_changes",
                {
                  event: "*",
                  schema: "public",
                  table: "player_inventory",
                  filter: `player_id=eq.${gameState.playerId}`,
                },
                (payload) => {
                  loadInventory(); // Reload inventory when changes occur
                }
              )
              .subscribe();

            // Load initial positions of other players with their emojis
            const { data: otherPositions } = await supabaseClient
              .from("player_positions")
              .select(`
                player_id,
                x,
                y,
                players:player_id (
                  emoji
                )
              `)
              .eq("server_id", gameState.serverId)
              .neq("player_id", gameState.playerId);

            // Initialize other players' positions
            gameState.otherPlayers.clear();
            if (otherPositions) {
              otherPositions.forEach((pos) => {
                gameState.otherPlayers.set(pos.player_id, {
                  x: pos.x,
                  y: pos.y,
                  emoji: pos.players?.emoji || "üêª", // Use bear as fallback
                });
              });
            }

            // Initialize hotbar
            updateHotbarDisplay();

            initCanvas();
            renderMap();
            updateStatus();
            startLastActiveUpdates();

            // Start player animation
            requestAnimationFrame(animatePlayer);

            hideLoadingScreen();

            // Add this to the initGame function, after the player data is loaded
            // Find this section in initGame:
            if (!playerError && playerData) {
              document.getElementById("player-username").textContent = playerData.username;
              
              // Add this line:
              await checkAdminStatus();
            }
          } catch (error) {
            console.error("Error initializing game:", error);
          }
        }

        // Replace the initialization calls with:
        initGame();

        // Add window resize handler
        window.addEventListener("resize", () => {
          initCanvas();
          renderMap();
        });

        // Add a flag to prevent double cleanup
        let isCleaningUp = false;

        async function leaveServer() {
          if (!gameState.serverId || isCleaningUp) {
            return;
          }

          isCleaningUp = true;

          try {
            // Remove all realtime subscriptions
            if (gameState.resourceChannel) {
              await gameState.resourceChannel.unsubscribe();
            }
            if (gameState.playerSubscription) {
              await gameState.playerSubscription.unsubscribe();
            }
            
            // Unsubscribe from map changes
            await supabaseClient.channel('map_changes').unsubscribe();
            
            // Delete server_players entry
            const { error: serverPlayerError } = await supabaseClient
              .from("server_players")
              .delete()
              .eq("player_id", gameState.playerId)
              .eq("server_id", gameState.serverId);

            if (serverPlayerError) {
              console.error("Error removing server player:", serverPlayerError);
            }

          } catch (error) {
            console.error("Error in leaveServer:", error);
          } finally {
            isCleaningUp = false;
          }
        }

        // Update event listeners to handle synchronously
        window.addEventListener("beforeunload", (event) => {
          // Call leaveServer synchronously
          leaveServer();
        });

        window.addEventListener("pagehide", () => {
          // Call leaveServer synchronously
          leaveServer();
        });

        // Keep visibility change for debugging but don't call leaveServer
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden") {
          }
        });

        async function handleLogout() {
          try {
            showLoadingScreen();

            // Clean up subscriptions
            if (gameState.playerSubscription) {
              await gameState.playerSubscription.unsubscribe();
            }

            // Clean up game state
            await leaveServer();

            // Sign out from Supabase
            const { error } = await supabaseClient.auth.signOut();
            if (error) throw error;

            // Reset game state
            gameState = {
              map: [],
              playerPos: null,
              health: 100,
              score: 0,
              inBattle: false,
              currentEnemy: null,
              playerHits: 0,
              enemyHits: 0,
              viewport: {
                x: 0,
                y: 0,
                scale: 1,
                isDragging: false,
                lastX: 0,
                lastY: 0,
                cellSizeMultiplier: isDemoMode ? 0.085 : 0.04,
              },
              playerId: null,
              otherPlayers: new Map(),
              configs: null,
              serverId: null,
              mapWidth: 20,
              mapHeight: 20,
              playerAnimation: {
                bounceOffset: 0,
              },
              playerSubscription: null,
              resourceChannel: null, 
              currentResource: null,
            };

            // Reset username display
            document.getElementById("player-username").textContent = "-";

            hideLoadingScreen();
            // Show auth screen
            showAuthScreen();
          } catch (error) {
            console.error("Error during logout:", error);
            hideLoadingScreen();
          }
        }

        const LOADING_MESSAGES = [
          { emoji: "üå≥", message: "Growing the forest..." },
          { emoji: "üèîÔ∏è", message: "Moving mountains..." },
          { emoji: "üå±", message: "Planting the plains..." },
          { emoji: "üåä", message: "Filling the oceans..." },
          { emoji: "ü¶ä", message: "Gathering the players..." },
          { emoji: "üêª", message: "Preparing your character..." },
        ];

        function showLoadingScreen() {
          const loadingScreen = document.getElementById("loading-screen");
          const loadingEmoji = document.querySelector(".loading-emoji");
          const loadingMessage = document.getElementById("loading-message");
          let messageIndex = 0;

          loadingScreen.style.display = "flex";

          // Cycle through messages every 2 seconds
          const interval = setInterval(() => {
            messageIndex = (messageIndex + 1) % LOADING_MESSAGES.length;
            const { emoji, message } = LOADING_MESSAGES[messageIndex];

            loadingEmoji.textContent = emoji;
            loadingMessage.textContent = message;
          }, 2000);

          // Store the interval ID on the loading screen element
          loadingScreen.dataset.intervalId = interval;
        }

        function hideLoadingScreen() {
          const loadingScreen = document.getElementById("loading-screen");
          // Clear the message cycling interval
          clearInterval(Number(loadingScreen.dataset.intervalId));
          loadingScreen.style.display = "none";
        }

        function showVictoryAnimation() {
          const battleMoves = document.getElementById("battle-moves");
          battleMoves.innerHTML = "üéâ Victory! +100 points üéâ";
        }

        function showDefeatAnimation() {
          const battleMoves = document.getElementById("battle-moves");
          battleMoves.innerHTML = "üò¢ Defeated! üò¢";
        }

        gameMap.addEventListener("wheel", (e) => {
          e.preventDefault(); // Prevent default scroll behavior

          // Determine zoom direction
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;

          // Calculate new cell size multiplier
          const newMultiplier =
            gameState.viewport.cellSizeMultiplier * zoomFactor;

          // Adjust zoom limits to account for larger emojis
          const minZoom = 0.02; // Keep minimum zoom the same
          const maxZoom = 0.12; // Slightly reduced from 0.15 to prevent overlapping

          if (newMultiplier >= minZoom && newMultiplier <= maxZoom) {
            gameState.viewport.cellSizeMultiplier = newMultiplier;
            renderMap();
          }
        });

        function animatePlayer() {
          // Create a smooth bounce using sine wave
          gameState.playerAnimation.bounceOffset =
            Math.sin(Date.now() * 0.003) * 3;

          // Update only the player position
          if (gameState.playerPos) {
            renderMap();
          }

          // Continue the animation loop
          requestAnimationFrame(animatePlayer);
        }

        // Update the handleHotbarSelection function
        function handleHotbarSelection(e) {
          // Only handle number keys 1-9 and 0
          const key = e.key;
          if (!gameState.inBattle && key >= "0" && key <= "9") {
            const slotNumber = key === "0" ? 10 : parseInt(key);

            // Remove selected class from all slots
            document.querySelectorAll(".hotbar-slot").forEach((slot) => {
              slot.classList.remove("selected");
            });

            // Add selected class to the clicked slot
            const selectedSlot = document.querySelector(
              `.hotbar-slot[data-slot="${slotNumber}"]`
            );
            if (selectedSlot) {
              selectedSlot.classList.add("selected");
              gameState.inventory.selectedSlot = slotNumber;
              debouncedUseItem();
            }
          }
        }

        // Add click handler for hotbar slots
        document.addEventListener("DOMContentLoaded", async () => {
          // Existing hotbar slot event listeners
          document.querySelectorAll(".hotbar-slot").forEach((slot) => {
            slot.addEventListener("click", () => {
              const slotNumber = parseInt(slot.dataset.slot);

              // Remove selected class from all slots
              document.querySelectorAll(".hotbar-slot").forEach((s) => {
                s.classList.remove("selected");
              });

              // Add selected class to clicked slot
              slot.classList.add("selected");
              gameState.inventory.selectedSlot = slotNumber;
              debouncedUseItem();
            });
          });

          // Load recipes after DOM is loaded
          await loadRecipes();
        });

        async function loadRecipes() {
          try {
            const { data: recipes, error } = await supabaseClient
              .from("crafting_recipes")
              .select(`
                id,
                quantity_produced,
                is_structure,
                structure_id,
                result_item_id,
                result_item:result_item_id (id, emoji, name),
                crafting_ingredients (
                  quantity_required,
                  item_id (id, emoji, name)
                )
              `).filter('is_structure', 'eq', false); // Only load non-structure recipes

            if (error) throw error;

            // Store recipes in game state
            gameState.crafting.recipes = recipes;

            const recipesContainer = document.getElementById("available-recipes");
            recipesContainer.innerHTML = "<h4>Available Recipes:</h4>";

            recipes.forEach((recipe, index) => {
              const recipeDiv = document.createElement("div");
              recipeDiv.className = "recipe-item";
              recipeDiv.onclick = () => {
                gameState.crafting.selectedRecipeIndex = index;
                document
                  .querySelectorAll(".recipe-item")
                  .forEach((item) => item.classList.remove("selected"));
                recipeDiv.classList.add("selected");
                showRecipeDetails(recipe);
              };

              recipeDiv.innerHTML = `${recipe.result_item.emoji} ${recipe.result_item.name}`;
              recipesContainer.appendChild(recipeDiv);
            });
          } catch (error) {
            console.error("Error loading recipes:", error);
          }
        }

        let selectedRecipe = null;

        function showRecipeDetails(recipe) {
          selectedRecipe = recipe;
          const detailsDiv = document.getElementById("recipe-details");

          let ingredientsList = recipe.crafting_ingredients
            .map(
              (ing) =>
                `${ing.quantity_required}x ${ing.item_id.emoji} ${ing.item_id.name}`
            )
            .join("<br>");

          detailsDiv.innerHTML = `
            <h4>Recipe Details:</h4>
            <div class="recipe-result">
              Creates: ${recipe.quantity_produced}x ${recipe.result_item.emoji} ${recipe.result_item.name}
            </div>
            <div class="recipe-ingredients">
              Requires:<br>
              ${ingredientsList}
            </div>
          `;

          document.getElementById("craft-button").style.display = "block";
        }

        async function craftSelectedRecipe() {
          if (!selectedRecipe) return;

          try {
            const { data, error } = await supabaseClient.rpc("handle_crafting", {
              p_player_id: gameState.playerId,
              p_recipe_id: selectedRecipe.id,
            });

            if (error) throw error;

            if (data.success) {
              showCollectionMessage(data.message);
              await loadInventory(); // Reload inventory after successful craft
            } else {
              showCollectionMessage(data.message); // Show what's missing
            }
          } catch (error) {
            console.error("Error crafting item:", error);
          }
        }

        // Replace the loadInventory function with this version
        async function loadInventory() {
          try {
            const { data, error } = await supabaseClient
              .from("player_inventory")
              .select("slot, item_id, quantity")
              .eq("player_id", gameState.playerId);

            if (error) throw error;

            // Create a new inventory state
            const newItems = {};
            const newStacks = {};

            // Load items from database
            for (const item of data) {
              // Get emoji from items table
              const { data: itemData, error: itemError } = await supabaseClient
                .from("items")
                .select("emoji")
                .eq("id", item.item_id)
                .single();

              if (itemError) {
                console.error("Error fetching item data:", itemError);
                continue;
              }

              if (itemData) {
                newItems[item.slot] = itemData.emoji;
                newStacks[item.slot] = item.quantity;
              }
            }

            // Update game state with new inventory
            gameState.inventory.items = newItems;
            gameState.inventory.stacks = newStacks;

            // Update display
            requestAnimationFrame(updateHotbarDisplay);
          } catch (error) {
            console.error("Error loading inventory:", error);
          }
        }

        async function setupPlayerSubscriptions() {
          try {
            // Unsubscribe from any existing subscriptions
            if (gameState.playerSubscription) {
              gameState.playerSubscription.unsubscribe();
            }
            if (gameState.resourceChannel) {
              gameState.resourceChannel.unsubscribe();
            }

            // Subscribe to player position changes
            gameState.playerSubscription = supabaseClient
              .channel("player_positions")
              .on(
                "postgres_changes",
                {
                  event: "*",
                  schema: "public",
                  table: "player_positions",
                  filter: `server_id=eq.${gameState.serverId}`,
                },
                async (payload) => {
                  if (!gameState.playerPos) return;

                  const position = payload.new;
                  if (position.player_id === gameState.playerId) return;

                  // Get player's emoji from players table
                  const { data: playerData, error: playerError } = await supabaseClient
                    .from("players")
                    .select("emoji")
                    .eq("id", position.player_id)
                    .single();

                  if (playerError) {
                    console.error("Error fetching player emoji:", playerError);
                    return;
                  }

                  switch (payload.eventType) {
                    case "INSERT":
                    case "UPDATE":
                      gameState.otherPlayers.set(position.player_id, {
                        x: position.x,
                        y: position.y,
                        emoji: playerData.emoji || "üêª", // Use bear as fallback
                      });
                      break;
                    case "DELETE":
                      gameState.otherPlayers.delete(position.player_id);
                      break;
                  }
                  renderMap();
                }
              )
              .subscribe();

            // Set up resource spawns subscription
            gameState.resourceChannel = supabaseClient
              .channel('resource_changes')
              .on(
                'postgres_changes',
                {
                  event: '*',
                  schema: 'public',
                  table: 'resource_spawns',
                  filter: `server_id=eq.${gameState.serverId}`
                },
                async (payload) => {
                  // Only process if we're on a tile
                  if (!gameState.playerPos) return;

                  const currentX = gameState.playerPos.x;
                  const currentY = gameState.playerPos.y;

                  // Clear UI immediately for any DELETE event at our position
                  if (payload.eventType === 'DELETE' && 
                      payload.old && 
                      payload.old.x === currentX && 
                      payload.old.y === currentY) {
                    gameState.currentResource = null;
                    const actionsDisplay = document.getElementById("tile-actions");
                    const resourcesDisplay = document.getElementById("tile-resources");
                    if (actionsDisplay) actionsDisplay.textContent = "";
                    if (resourcesDisplay) resourcesDisplay.textContent = "";
                    return;
                  }
                  
                  // For all other events, verify current state
                  await checkForResources();
                }
              )
              .subscribe();

            // Add subscription for map terrain changes
            supabaseClient
              .channel('map_changes')
              .on(
                'postgres_changes',
                {
                  event: '*',
                  schema: 'public',
                  table: 'map_data',
                  filter: `server_id=eq.${gameState.serverId}`
                },
                async (payload) => {
                  if (payload.new) {
                    const { x, y, terrain_type } = payload.new;
                    
                    // Get the terrain details
                    const terrain = TERRAIN_TYPES[terrain_type];
                    if (terrain) {
                      // Update the local map data
                      if (!gameState.map[y]) gameState.map[y] = [];
                      gameState.map[y][x] = terrain;
                      
                      // Re-render the map
                      renderMap();
                      
                      // Update tile info if player is on this tile
                      if (gameState.playerPos && 
                          gameState.playerPos.x === x && 
                          gameState.playerPos.y === y) {
                        updateTileInfo();
                      }
                    }
                  }
                }
              )
              .subscribe();

            console.log('All subscriptions set up successfully');
          } catch (error) {
            console.error('Error setting up subscriptions:', error);
          }
        }

        // Add visibility change handler outside of setupPlayerSubscriptions
        document.addEventListener('visibilitychange', async () => {
          if (document.visibilityState === 'visible') {
            console.log('Tab became visible, refreshing resource display');
            // Re-check resources when tab becomes visible
            if (gameState.playerPos) {
              await checkForResources();
            }
          }
        });

        // Find the updateTileInfo function and replace it with this version
        async function updateTileInfo() {
          if (!gameState.playerPos) {
            return;
          }

          if (!gameState.map || !gameState.map[gameState.playerPos.y]) {
            return;
          }

          const currentTile = gameState.map[gameState.playerPos.y][gameState.playerPos.x];

          // Update terrain
          const terrainDisplay = document.getElementById("tile-terrain");
          if (terrainDisplay) {
            terrainDisplay.textContent = currentTile.emoji;
          }

          // Get resource and tool info for current terrain
          try {
            const { data: actionData, error } = await supabaseClient
              .from('item_terrain_actions')
              .select(`
                item_id,
                result_item_id,
                items:item_id (emoji),
                result_items:result_item_id (emoji)
              `)
              .eq('terrain_type', Object.keys(TERRAIN_TYPES).find(
                type => TERRAIN_TYPES[type].emoji === currentTile.emoji
              ));

            if (error) throw error;

            // Update resources display
            const resourcesDisplay = document.getElementById("tile-resources");
            if (resourcesDisplay) {
              if (actionData && actionData.length > 0) {
                // Show both tool and resource emojis
                resourcesDisplay.textContent = `${actionData[0].result_items.emoji}${actionData[0].items.emoji}`;
              } else {
                resourcesDisplay.textContent = "";
              }
            }
          } catch (error) {
            console.error('Error fetching terrain actions:', error);
          }

          // Check for resources at current position (keep existing resource check)
          checkForResources();
        }

        async function checkForResources() {
          try {
            // First check for resource spawns
            const { data: resources, error: resourceError } = await supabaseClient
              .from('resource_spawns')
              .select(`
                *,
                items:item_id (emoji, name)
              `)
              .eq('server_id', gameState.serverId)
              .eq('x', gameState.playerPos.x)
              .eq('y', gameState.playerPos.y)
              .maybeSingle();

            if (resourceError) throw resourceError;

            // Then check for structures
            const { data: mapData, error: mapError } = await supabaseClient
              .from('map_data')
              .select('metadata')
              .eq('server_id', gameState.serverId)
              .eq('x', gameState.playerPos.x)
              .eq('y', gameState.playerPos.y)
              .maybeSingle();

            if (mapError) throw mapError;

            // Update actions display and label
            const actionsDisplay = document.getElementById("tile-actions");
            const actionsLabel = document.querySelector('.hotbar-slot[data-slot="actions"] .slot-label');
            
            if (actionsDisplay && actionsLabel) {
              if (resources) {
                // It's a resource spawn
                gameState.currentResource = resources;
                actionsDisplay.textContent = resources.items.emoji;
                actionsLabel.textContent = 'E to pick up';
              } else if (mapData?.metadata?.structure_id) {
                // It's a structure
                gameState.currentResource = null;
                
                if (mapData.metadata.structure_id === 'STORAGE_CHEST') {
                  // Use the terrain emoji from the current location display
                  const terrainEmoji = document.getElementById("tile-terrain").textContent;
                  actionsDisplay.textContent = terrainEmoji;
                  // Show different message based on ownership
                  actionsLabel.textContent = mapData.metadata.owner_id === gameState.playerId ? 
                    'E to open' : 'Not your storage';
                } else {
                  actionsDisplay.textContent = ""; // Structure emoji is shown in terrain
                  actionsLabel.textContent = 'E to interact';
                }
              } else {
                // Nothing to interact with
                gameState.currentResource = null;
                actionsDisplay.textContent = "";
                actionsLabel.textContent = ''; // Leave blank for non-interactive tiles
              }
            }
          } catch (error) {
            console.error('Error checking resources:', error);
          }
        }

        // Update the collectResource function to check ownership before opening storage
        async function collectResource() {
          if (!gameState.playerPos) return;

          try {
            // Check if there's a structure at the current position
            const { data: mapData, error: mapError } = await supabaseClient
              .from('map_data')
              .select('metadata')
              .match({
                server_id: gameState.serverId,
                x: gameState.playerPos.x,
                y: gameState.playerPos.y
              })
              .single();

            if (mapError) throw mapError;

            // If this is a storage chest, verify ownership before opening
            if (mapData?.metadata?.structure_id === 'STORAGE_CHEST') {
              const ownerId = mapData.metadata.owner_id;
              
              if (ownerId !== gameState.playerId) {
                showCollectionMessage("You don't own this storage chest");
                return;
              }
              
              // If we get here, the player owns the chest
              openStorageMenu(gameState.serverId, gameState.playerPos.x, gameState.playerPos.y);
              return;
            }

            // Rest of existing resource collection code...
            if (!gameState.currentResource) return;

            const { data, error } = await supabaseClient.rpc('collect_resource', {
              p_player_id: gameState.playerId,
              p_server_id: gameState.serverId,
              p_x: gameState.playerPos.x,
              p_y: gameState.playerPos.y
            });

            if (error) throw error;

            if (data.success) {
              showCollectionMessage(data.message);
              await loadInventory();
            } else {
              showCollectionMessage(data.message);
              await checkForResources();
            }
          } catch (error) {
            console.error('Error collecting resource:', error);
            await checkForResources();
          }
        }

        function navigateRecipes(direction) {
          const recipes = gameState.crafting.recipes;
          if (recipes.length === 0) return;

          // Update selected index
          let newIndex = gameState.crafting.selectedRecipeIndex + direction;
          if (newIndex >= recipes.length) newIndex = 0;
          if (newIndex < 0) newIndex = recipes.length - 1;

          gameState.crafting.selectedRecipeIndex = newIndex;

          // Update UI
          document.querySelectorAll(".recipe-item").forEach((item, index) => {
            item.classList.toggle("selected", index === newIndex);
          });

          // Show details of selected recipe
          showRecipeDetails(recipes[newIndex]);
        }

        function openCraftingMenu() {
          gameState.crafting.isOpen = true;
          const modal = document.getElementById("crafting-modal");
          modal.classList.add("active");

          // Select first recipe by default
          if (gameState.crafting.recipes.length > 0) {
            gameState.crafting.selectedRecipeIndex = 0;
            const firstRecipe = document.querySelector(".recipe-item");
            if (firstRecipe) {
              firstRecipe.classList.add("selected");
              showRecipeDetails(gameState.crafting.recipes[0]);
            }
          }
        }

        // Add new function to load available structures
        async function loadStructures() {
          try {
            // First get all structures
            const { data: structures, error: structuresError } = await supabaseClient
              .from("structures")
              .select(`
                id,
                emoji,
                name,
                description,
                allowed_terrain
              `);

            if (structuresError) throw structuresError;

            // Then get their recipes
            const { data: recipes, error: recipesError } = await supabaseClient
              .from("crafting_recipes")
              .select(`
                id,
                structure_id,
                crafting_ingredients (
                  quantity_required,
                  item_id (id, emoji, name)
                )
              `)
              .filter('is_structure', 'eq', true);

            if (recipesError) throw recipesError;

            // Combine the data
            const structuresWithRecipes = structures.map(structure => {
              const recipe = recipes.find(r => r.structure_id === structure.id);
              return {
                ...structure,
                recipe: recipe
              };
            });

            gameState.building.structures = structuresWithRecipes;
          } catch (error) {
            console.error("Error loading structures:", error);
          }
        }

        // Add build menu HTML after crafting modal
        `<div id="build-modal" class="modal">
          <div class="modal-content">
            <div class="modal-header">
              <h2>Build Structure</h2>
              <span class="close-button" onclick="closeBuildMenu()">&times;</span>
            </div>
            <div id="build-panel">
              <div id="available-structures"></div>
              <div id="structure-details"></div>
              <button id="build-button" onclick="buildSelectedStructure()" style="display: none">
                Build (B)
              </button>
            </div>
          </div>
        </div>`

        // Add build menu functions
        function openBuildMenu() {
          gameState.building.isOpen = true;
          const modal = document.getElementById("build-modal");
          modal.classList.add("active");
          updateAvailableStructures();

          // Select first structure by default
          if (gameState.building.structures.length > 0) {
            gameState.building.selectedStructureIndex = 0;
            const firstStructure = document.querySelector(".structure-item");
            if (firstStructure) {
              firstStructure.classList.add("selected");
              showStructureDetails(gameState.building.structures[0]);
            }
          }
        }

        function closeBuildMenu() {
          gameState.building.isOpen = false;
          gameState.building.selectedStructureIndex = -1;
          const modal = document.getElementById("build-modal");
          modal.classList.remove("active");
          document.getElementById("build-button").style.display = "none";
          document.getElementById("structure-details").innerHTML = "";
          document.querySelectorAll(".structure-item").forEach(item => item.classList.remove("selected"));
        }

        function updateAvailableStructures() {
          const structuresContainer = document.getElementById("available-structures");
          structuresContainer.innerHTML = "<h4>Available Structures:</h4>";

          gameState.building.structures.forEach((structure, index) => {
            const structureDiv = document.createElement("div");
            structureDiv.className = "structure-item";
            structureDiv.onclick = () => {
              gameState.building.selectedStructureIndex = index;
              document.querySelectorAll(".structure-item").forEach(item => item.classList.remove("selected"));
              structureDiv.classList.add("selected");
              showStructureDetails(structure);
            };
            structureDiv.innerHTML = `${structure.emoji} ${structure.name}`;
            structuresContainer.appendChild(structureDiv);
          });
        }

        function showStructureDetails(structure) {
          const detailsDiv = document.getElementById("structure-details");
          
          if (!structure.recipe || !structure.recipe.crafting_ingredients) {
            detailsDiv.innerHTML = `
              <h4>Structure Details:</h4>
              <div class="structure-description">
                ${structure.description || ""}
              </div>
              <div class="structure-requirements">
                No recipe found
              </div>
            `;
            return;
          }

          let requirementsList = structure.recipe.crafting_ingredients
            .map(ing => `${ing.quantity_required}x ${ing.item_id.emoji} ${ing.item_id.name}`)
            .join("<br>");

          detailsDiv.innerHTML = `
            <h4>Structure Details:</h4>
            <div class="structure-description">
              ${structure.description || ""}
            </div>
            <div class="structure-requirements">
              Requires:<br>
              ${requirementsList}<br>
              Can be built on: ${TERRAIN_TYPES[structure.allowed_terrain].emoji}
            </div>
          `;

          document.getElementById("build-button").style.display = "block";
        }

        async function buildSelectedStructure() {
          if (gameState.building.selectedStructureIndex === -1) return;

          const structure = gameState.building.structures[gameState.building.selectedStructureIndex];
          if (!structure.recipe) {
            showCollectionMessage("No recipe found for this structure");
            return;
          }

          try {

            const { data, error } = await supabaseClient.rpc("handle_crafting", {
              p_player_id: gameState.playerId,
              p_recipe_id: structure.recipe.id, // This was the issue - we need to use the recipe ID
              p_x: gameState.playerPos.x,
              p_y: gameState.playerPos.y,
              p_server_id: gameState.serverId
            });

            if (error) {
              console.error("Building error:", error);
              throw error;
            }

            if (data.success) {
              showCollectionMessage(data.message);
              closeBuildMenu();
              renderMap();
            } else {
              showCollectionMessage(data.message);
            }
          } catch (error) {
            console.error("Error building structure:", error);
            showCollectionMessage("Error building structure");
          }
        }

        // Add structure navigation
        function navigateStructures(direction) {
          const structures = gameState.building.structures;
          if (structures.length === 0) return;

          let newIndex = gameState.building.selectedStructureIndex + direction;
          if (newIndex >= structures.length) newIndex = 0;
          if (newIndex < 0) newIndex = structures.length - 1;

          gameState.building.selectedStructureIndex = newIndex;

          document.querySelectorAll(".structure-item").forEach((item, index) => {
            item.classList.toggle("selected", index === newIndex);
          });

          showStructureDetails(structures[newIndex]);
        }

        function closeCraftingMenu() {
          gameState.crafting.isOpen = false;
          gameState.crafting.selectedRecipeIndex = -1;
          const modal = document.getElementById("crafting-modal");
          modal.classList.remove("active");
          document.getElementById("craft-button").style.display = "none";
          document.getElementById("recipe-details").innerHTML = "";
          document.querySelectorAll(".recipe-item").forEach(item => item.classList.remove("selected"));
        }

        // After the gameState declaration, add selectedSlotForMove
        let selectedSlotForMove = null;

        // Add these functions after updateHotbarDisplay()
        function selectSlotForMove(slot) {
          // Clear previous selection
          document.querySelectorAll('.hotbar-slot').forEach(s => {
            s.classList.remove('move-source');
          });

          if (selectedSlotForMove === slot) {
            // Clicking same slot again cancels the move
            selectedSlotForMove = null;
          } else {
            selectedSlotForMove = slot;
            // Highlight the selected slot
            document.querySelector(`.hotbar-slot[data-slot="${slot}"]`).classList.add('move-source');
          }
        }

        async function moveItem(fromSlot, toSlot) {
          try {
            const { data, error } = await supabaseClient.rpc('move_inventory_item', {
              p_player_id: gameState.playerId,
              p_from_slot: fromSlot,
              p_to_slot: toSlot
            });

            if (error) throw error;

            if (data.success) {
              await loadInventory();
              showCollectionMessage(data.message);
            } else {
              showCollectionMessage(data.message);
            }
          } catch (error) {
            console.error('Error moving item:', error);
            showCollectionMessage('Failed to move item');
          }
        }

        // Replace the hotbar slot click handler with this updated version
        document.querySelectorAll('.hotbar-slot').forEach(slot => {
          slot.addEventListener('click', async () => {
            const slotNumber = parseInt(slot.dataset.slot);

            if (selectedSlotForMove !== null) {
              // If we already have a slot selected, handle the move
              if (selectedSlotForMove !== slotNumber) {
                await moveItem(selectedSlotForMove, slotNumber);
              }
              // Clear selection
              selectedSlotForMove = null;
              document.querySelectorAll('.hotbar-slot').forEach(s => {
                s.classList.remove('move-source');
              });
            } else if (gameState.inventory.items[slotNumber]) {
              // If clicking a slot with an item, start move operation
              selectSlotForMove(slotNumber);
            } else {
              // Regular slot selection for item use
              document.querySelectorAll('.hotbar-slot').forEach(s => {
                s.classList.remove('selected');
              });
              slot.classList.add('selected');
              gameState.inventory.selectedSlot = slotNumber;
              debouncedUseItem();
            }
          });
        });

        let currentStorage = {
          serverId: null,
          x: null,
          y: null
        };

        // Update the openStorageMenu function to select the first slot by default
        function openStorageMenu(serverId, x, y) {
          currentStorage = { serverId, x, y };
          const modal = document.getElementById("storage-modal");
          modal.classList.add("active");
          loadStorageContents().then(() => {
            // Select first slot by default after contents are loaded
            selectStorageSlot(1);
          });
        }

        function closeStorageMenu() {
          currentStorage = { serverId: null, x: null, y: null };
          selectedStorageSlot = null;
          const modal = document.getElementById("storage-modal");
          modal.classList.remove("active");
        }

        // Update loadStorageContents to handle clicks
        async function loadStorageContents() {
          try {
            // Load storage contents
            const { data: contents, error } = await supabaseClient
              .from('storage_inventories')
              .select(`
                slot,
                quantity,
                items:item_id (
                  id,
                  emoji,
                  name
                )
              `)
              .match({
                server_id: currentStorage.serverId,
                x: currentStorage.x,
                y: currentStorage.y
              });

            if (error) throw error;

            // Generate storage slots
            const storageGrid = document.querySelector('.storage-grid');
            storageGrid.innerHTML = '';

            // Create 20 storage slots
            for (let i = 1; i <= 20; i++) {
              const slot = document.createElement('div');
              slot.className = 'storage-slot';
              slot.dataset.slot = i;

              const content = contents.find(item => item.slot === i);
              if (content) {
                slot.innerHTML = `
                  <div class="slot-content" data-stack="${content.quantity}">
                    ${content.items.emoji}
                  </div>
                `;
              }

              // Update click handler to move cursor
              slot.onclick = () => {
                cursorPosition.section = 'storage';
                cursorPosition.slot = i;
                updateCursorVisuals();
                updateTransferButton();
              };
              storageGrid.appendChild(slot);
            }

            // Generate player inventory slots
            const inventoryGrid = document.querySelector('.player-inventory-grid');
            inventoryGrid.innerHTML = '';

            // Create 10 inventory slots
            for (let i = 1; i <= 10; i++) {
              const slot = document.createElement('div');
              slot.className = 'storage-slot inventory-slot';
              slot.dataset.slot = i;

              // Add item if exists in player's inventory
              if (gameState.inventory.items[i]) {
                slot.innerHTML = `
                  <div class="slot-content" data-stack="${gameState.inventory.stacks[i] || ''}">
                    ${gameState.inventory.items[i]}
                  </div>
                `;
              }

              // Add slot number indicator
              const slotNumber = document.createElement('div');
              slotNumber.className = 'hotkey';
              slotNumber.textContent = i === 10 ? '0' : i;
              slot.appendChild(slotNumber);

              // Update click handler to move cursor
              slot.onclick = () => {
                cursorPosition.section = 'inventory';
                cursorPosition.slot = i;
                updateCursorVisuals();
                updateTransferButton();
              };
              inventoryGrid.appendChild(slot);
            }

            // Update cursor visuals
            updateCursorVisuals();
            updateTransferButton();
          } catch (error) {
            console.error('Error loading storage contents:', error);
            showCollectionMessage('Error loading storage contents');
          }
        }

        function selectStorageSlot(slot) {
          document.querySelectorAll('.storage-slot').forEach(s => {
            s.classList.remove('selected');
          });
          
          if (selectedStorageSlot === slot) {
            selectedStorageSlot = null;
          } else {
            selectedStorageSlot = slot;
            document.querySelector(`.storage-slot[data-slot="${slot}"]`).classList.add('selected');
          }
        }

        // Add function to select inventory slot
        function selectInventorySlot(slot) {
          document.querySelectorAll('.inventory-slot').forEach(s => {
            s.classList.remove('selected');
          });
          
          if (gameState.inventory.selectedSlot === slot) {
            gameState.inventory.selectedSlot = null;
          } else {
            gameState.inventory.selectedSlot = slot;
            document.querySelector(`.inventory-slot[data-slot="${slot}"]`).classList.add('selected');
          }
        }

        // Update handleStorageAction to properly check selected slots
        async function handleStorageAction(action) {
          if (!selectedStorageSlot) {
            showCollectionMessage('Select a storage slot');
            return;
          }
          
          if (!gameState.inventory.selectedSlot) {
            showCollectionMessage('Select an inventory slot');
            return;
          }

          try {
            const { data, error } = await supabaseClient.rpc('handle_storage_action', {
              p_player_id: gameState.playerId,
              p_server_id: currentStorage.serverId,
              p_x: currentStorage.x,
              p_y: currentStorage.y,
              p_action: action,
              p_storage_slot: selectedStorageSlot,
              p_inventory_slot: gameState.inventory.selectedSlot
            });

            if (error) throw error;

            if (data.success) {
              showCollectionMessage(data.message);
              
              // Update local gameState for immediate UI feedback
              if (action === 'DEPOSIT') {
                delete gameState.inventory.items[gameState.inventory.selectedSlot];
                delete gameState.inventory.stacks[gameState.inventory.selectedSlot];
              }

              // First update the main inventory
              await loadInventory();

              // Then update the storage modal display
              await loadStorageContents();

              // Clear selections after successful action
              selectedStorageSlot = null;
              gameState.inventory.selectedSlot = null;
              
              // Update selection visuals
              document.querySelectorAll('.storage-slot, .inventory-slot').forEach(slot => {
                slot.classList.remove('selected');
              });

              // Update cursor visuals
              updateCursorVisuals();
            } else {
              showCollectionMessage(data.message);
            }
          } catch (error) {
            console.error('Error handling storage action:', error);
            showCollectionMessage('Error performing storage action');
          }
        }

        // Add keyboard shortcuts for storage actions
        document.addEventListener("keydown", (e) => {
          if (!document.getElementById("storage-modal").classList.contains("active")) return;
          
          const key = e.key.toLowerCase();
          switch (key) {
            case "escape":
              closeStorageMenu();
              break;
            case "arrowleft":
              e.preventDefault();
              moveCursor('left');
              break;
            case "arrowright":
              e.preventDefault();
              moveCursor('right');
              break;
            case "arrowup":
              e.preventDefault();
              moveCursor('up');
              break;
            case "arrowdown":
              e.preventDefault();
              moveCursor('down');
              break;
            case "tab":
              e.preventDefault();
              moveCursor('tab');
              break;
            case "x":
              e.preventDefault();
              executeStorageAction();
              break;
          }
        });

        // Add these variables near the top with other state variables
        let cursorPosition = {
          section: 'storage', // 'storage' or 'inventory'
          slot: 1,
          lastStorageSlot: 1,
          lastInventorySlot: 1
        };

        // Add this function to handle cursor movement
        function moveCursor(direction) {
          const isStorage = cursorPosition.section === 'storage';
          const maxSlots = isStorage ? 20 : 10;
          const columns = isStorage ? 5 : 3;  // Different column count for each section
          let currentSlot = cursorPosition.slot;
          let newSlot = currentSlot;

          switch (direction) {
            case 'left':
              if (currentSlot % columns !== 1) newSlot--;
              break;
            case 'right':
              if (currentSlot % columns !== 0 && currentSlot < maxSlots) newSlot++;
              break;
            case 'up':
              if (currentSlot > columns) newSlot -= columns;
              break;
            case 'down':
              if (currentSlot + columns <= maxSlots) newSlot += columns;
              break;
            case 'tab':
              // Switch between storage and inventory sections
              cursorPosition.section = isStorage ? 'inventory' : 'storage';
              // Restore last position for this section
              newSlot = isStorage ? cursorPosition.lastInventorySlot : cursorPosition.lastStorageSlot;
              break;
          }

          // Save last position for current section before switching
          if (direction === 'tab') {
            if (isStorage) {
              cursorPosition.lastStorageSlot = currentSlot;
            } else {
              cursorPosition.lastInventorySlot = currentSlot;
            }
          }

          cursorPosition.slot = newSlot;
          updateCursorVisuals();
          updateTransferButton();  // Add this line

          // Add visual feedback for active section
          document.querySelectorAll('.inventory-section').forEach(section => {
            section.classList.remove('active');
          });
          const activeSection = cursorPosition.section === 'storage' ? 
            document.querySelector('.inventory-section:first-child') :
            document.querySelector('.inventory-section:last-child');
          if (activeSection) {
            activeSection.classList.add('active');
          }
        }

        // Add this function to update visual cursor position
        function updateCursorVisuals() {
          // Remove cursor class from all slots
          document.querySelectorAll('.storage-slot').forEach(slot => {
            slot.classList.remove('cursor');
          });

          // Add cursor class to current slot
          const selector = cursorPosition.section === 'storage' 
            ? `.storage-grid .storage-slot[data-slot="${cursorPosition.slot}"]`
            : `.player-inventory-grid .storage-slot[data-slot="${cursorPosition.slot}"]`;
          
          const currentSlot = document.querySelector(selector);
          if (currentSlot) {
            currentSlot.classList.add('cursor');
          }
        }

        // Add this function to select the slot under the cursor
        function selectSlotUnderCursor() {
          if (cursorPosition.section === 'storage') {
            selectStorageSlot(cursorPosition.slot);
          } else {
            selectInventorySlot(cursorPosition.slot);
          }
          updateTransferButton();  // Add this line
        }

        // Add this function to execute storage action when slots are selected
        function executeStorageAction() {
          // Get the source slot (where the cursor is)
          const isSourceStorage = cursorPosition.section === 'storage';
          const cursorSlot = cursorPosition.slot;
          
          // Check if source slot has an item
          const sourceSlotElement = isSourceStorage 
            ? document.querySelector(`.storage-grid .storage-slot[data-slot="${cursorSlot}"]`)
            : document.querySelector(`.player-inventory-grid .storage-slot[data-slot="${cursorSlot}"]`);
          
          const hasSourceItem = sourceSlotElement?.querySelector('.slot-content') !== null;
          if (!hasSourceItem) {
            showCollectionMessage('Select a slot with an item first');
            return;
          }

          // Set the source slot based on cursor position
          if (isSourceStorage) {
            selectedStorageSlot = cursorSlot;
            
            // Find first empty inventory slot
            for (let i = 1; i <= 10; i++) {
              if (!gameState.inventory.items[i]) {
                gameState.inventory.selectedSlot = i;
                handleStorageAction('WITHDRAW');
                return;
              }
            }
            showCollectionMessage('No available inventory slots');
          } else {
            gameState.inventory.selectedSlot = cursorSlot;
            
            // Find first empty storage slot
            const emptySlot = document.querySelector(`.storage-grid .storage-slot:not(:has(.slot-content))`);
            if (emptySlot) {
              selectedStorageSlot = parseInt(emptySlot.dataset.slot);
              handleStorageAction('DEPOSIT');
            } else {
              showCollectionMessage('No available storage slots');
            }
          }
        }

        // Update openStorageMenu to initialize cursor
        function openStorageMenu(serverId, x, y) {
          currentStorage = { serverId, x, y };
          const modal = document.getElementById("storage-modal");
          modal.classList.add("active");
          
          // Reset cursor position
          cursorPosition = {
            section: 'storage',
            slot: 1,
            lastStorageSlot: 1,
            lastInventorySlot: 1
          };
          
          loadStorageContents().then(() => {
            updateCursorVisuals();
          });
        }

        // Add this function to update the transfer button state
        function updateTransferButton() {
          const transferButton = document.getElementById('transfer-button');
          
          // Get the slot under cursor
          const cursorSlot = cursorPosition.section === 'storage' 
            ? document.querySelector(`.storage-grid .storage-slot[data-slot="${cursorPosition.slot}"]`)
            : document.querySelector(`.player-inventory-grid .storage-slot[data-slot="${cursorPosition.slot}"]`);

          // Check if cursor is over an item
          const hasSourceItem = cursorSlot?.querySelector('.slot-content') !== null;

          // Simply enable/disable button based on whether cursor is over an item
          transferButton.disabled = !hasSourceItem;
          transferButton.textContent = 'Transfer Item (X)';
        }
    </script>
  </body>
</html>
