<!DOCTYPE html>
<html>
  <head>
    <title>Emoji Adventure</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config.js"></script>
    <script>
      function getEnvVariable(name) {
        if (window.env && window.env[name]) {
          return window.env[name];
        }
        console.error(`Environment variable ${name} not found`);
        return null;
      }

      // Initialize Supabase client
      const supabaseClient = supabase.createClient(
        getEnvVariable("NEXT_PUBLIC_SUPABASE_URL"),
        getEnvVariable("NEXT_PUBLIC_SUPABASE_ANON_KEY")
      );
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        font-family: Arial, sans-serif;
        background: #1a1a1a;
        color: white;
        overflow: hidden;
      }

      #game-container {
        text-align: center;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      #game-map {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #2a2a2a;
        padding: 20px;
        margin: 20px;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
        cursor: grab;
      }

      #map-canvas {
        position: absolute;
      }

      #status-bar {
        padding: 10px;
        background: #333;
        border-radius: 5px;
        display: flex;
        justify-content: space-around;
        margin: 10px 20px 0 20px;
      }

      #battle-screen {
        display: none;
        background: #333;
        padding: 20px;
        border-radius: 10px;
        margin: 20px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 300px;
      }

      .battle-option {
        margin: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        background: #4a4a4a;
        border: none;
        border-radius: 5px;
        color: white;
      }

      .battle-option:hover {
        background: #5a5a5a;
      }

      #game-over {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      #restart-button {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 18px;
        cursor: pointer;
        background: #4caf50;
        border: none;
        border-radius: 5px;
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="status-bar">
        <div>Health: <span id="health">100</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>
          Position: (<span id="position-x">-</span>,
          <span id="position-y">-</span>)
        </div>
      </div>
      <div id="game-map">
        <canvas id="map-canvas"></canvas>
      </div>
      <div id="battle-screen">
        <div id="battle-text"></div>
        <div id="battle-options">
          <button class="battle-option" onclick="chooseBattle('fight')">
            Fight
          </button>
          <button class="battle-option" onclick="chooseBattle('flee')">
            Flee
          </button>
        </div>
        <div id="attack-options" style="display: none">
          <button class="battle-option" onclick="chooseAttack('quick')">
            Quick Attack üå™Ô∏è
          </button>
          <button class="battle-option" onclick="chooseAttack('heavy')">
            Heavy Attack üî®
          </button>
          <button class="battle-option" onclick="chooseAttack('block')">
            Block üõ°Ô∏è
          </button>
        </div>
      </div>
      <div id="game-over">
        <h1>Game Over!</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-button" onclick="restartGame()">Play Again</button>
      </div>
    </div>

    <script>
      const MAP_SIZE = 120;
      const TERRAIN_TYPES = {
        FOREST: { emoji: "üå≥", encounter: "üê∫" },
        MOUNTAIN: { emoji: "üèîÔ∏è", encounter: "üêÜ" },
        PLAIN: { emoji: "üå±", encounter: "ü¶Å" },
        OCEAN: { emoji: "üåä", encounter: "ü¶à" },
      };

      let gameState = {
        map: [],
        playerPos: null,
        health: 100,
        score: 0,
        inBattle: false,
        currentEnemy: null,
        playerHits: 0,
        enemyHits: 0,
        viewport: {
          x: 0,
          y: 0,
          scale: 1,
          isDragging: false,
          lastX: 0,
          lastY: 0,
        },
        playerId: null,
        otherPlayers: new Map(),
        configs: null,
        serverId: null,
      };

      let lastActiveInterval;

      function startLastActiveUpdates() {
        if (lastActiveInterval) {
          clearInterval(lastActiveInterval);
        }

        lastActiveInterval = setInterval(async () => {
          if (gameState.serverId) {
            try {
              await supabaseClient.rpc("increment_server_players", {
                server_id: gameState.serverId,
              });
            } catch (error) {
              console.error("Error updating last_active:", error);
            }
          }
        }, 30000);
      }

      async function fetchGameConfigs() {
        try {
          const { data, error } = await supabaseClient
            .from("game_configs")
            .select("*");

          if (error) throw error;

          // Convert array of configs to object
          const configs = {};
          data.forEach((config) => {
            configs[config.key] = config.value;
          });

          gameState.configs = configs;
          console.log("Game configs loaded:", configs);
        } catch (error) {
          console.error("Error fetching game configs:", error);
          // Use default values if configs can't be loaded
          gameState.configs = {
            encounter_rates: {
              FOREST: 0.3,
              MOUNTAIN: 0.4,
              PLAIN: 0.2,
              OCEAN: 0.3,
            },
          };
        }
      }

      async function findOrCreateServer() {
        try {
          // First check if player is already in a server
          const { data: existingServer, error: existingError } =
            await supabaseClient
              .from("server_players")
              .select("server_id, servers!inner(*)")
              .eq("player_id", gameState.playerId)
              .single();

          if (!existingError && existingServer) {
            // Player is already in a server, check if it's still active
            if (existingServer.servers.status === "active") {
              console.log(
                "Rejoining existing server:",
                existingServer.server_id
              );

              // Call increment_server_players to ensure count is correct
              await supabaseClient.rpc("increment_server_players", {
                server_id: existingServer.server_id,
              });

              gameState.serverId = existingServer.server_id;
              return existingServer.server_id;
            } else {
              // Server is inactive, remove player from it
              await supabaseClient.from("server_players").delete().match({
                server_id: existingServer.server_id,
                player_id: gameState.playerId,
              });
            }
          }

          // Look for an active server with space
          const { data: servers, error: serverError } = await supabaseClient
            .from("servers")
            .select("*")
            .eq("status", "active")
            .lt("current_players", 100)
            .order("current_players", { ascending: false })
            .limit(1);

          if (serverError) throw serverError;

          let serverId;

          if (servers && servers.length > 0) {
            // Join existing server
            serverId = servers[0].id;
            console.log("Joining existing server:", serverId);
          } else {
            // Create new server
            const { data: newServer, error: createError } = await supabaseClient
              .from("servers")
              .insert([
                {
                  name: `Server ${Math.floor(Math.random() * 1000)}`,
                  status: "active",
                  max_players: 100,
                  current_players: 0,
                },
              ])
              .select()
              .single();

            if (createError) throw createError;
            serverId = newServer.id;

            // Generate and store map for new server
            await generateAndStoreMap(serverId);
            console.log("Created new server:", serverId);
          }

          // Join server
          const { error: joinError } = await supabaseClient
            .from("server_players")
            .upsert([{ server_id: serverId, player_id: gameState.playerId }]);

          if (joinError) throw joinError;

          // Always call increment_server_players after joining
          await supabaseClient.rpc("increment_server_players", {
            server_id: serverId,
          });

          gameState.serverId = serverId;
          return serverId;
        } catch (error) {
          console.error("Error finding/creating server:", error);
          throw error;
        }
      }

      async function loadMap(serverId) {
        try {
          // Initialize empty map
          gameState.map = Array(MAP_SIZE)
            .fill()
            .map(() => Array(MAP_SIZE).fill(TERRAIN_TYPES.PLAIN));

          // Calculate total tiles needed
          const totalTiles = MAP_SIZE * MAP_SIZE;
          const pageSize = 1000;
          const totalPages = Math.ceil(totalTiles / pageSize);

          // Load map data in pages
          for (let page = 0; page < totalPages; page++) {
            const { data: mapData, error } = await supabaseClient
              .from("map_data")
              .select("x, y, terrain_type")
              .eq("server_id", serverId)
              .range(page * pageSize, (page + 1) * pageSize - 1);

            if (error) {
              console.error(`Error loading page ${page}:`, error);
              throw error;
            }

            // Populate map from database
            mapData.forEach((tile) => {
              if (
                tile.x >= 0 &&
                tile.x < MAP_SIZE &&
                tile.y >= 0 &&
                tile.y < MAP_SIZE &&
                TERRAIN_TYPES[tile.terrain_type]
              ) {
                gameState.map[tile.y][tile.x] =
                  TERRAIN_TYPES[tile.terrain_type];
              }
            });
          }

          renderMap();
        } catch (error) {
          console.error("Error loading map:", error);
          throw error;
        }
      }

      async function generateAndStoreMap(serverId) {
        try {
          const mapData = [];
          let debug_counts = {
            FOREST: 0,
            MOUNTAIN: 0,
            PLAIN: 0,
            OCEAN: 0,
          };

          for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
              const rand = Math.random();
              let terrainType;

              // Adjust thresholds to ensure better distribution
              if (rand < 0.25) {
                terrainType = "FOREST";
                debug_counts.FOREST++;
              } else if (rand < 0.5) {
                terrainType = "MOUNTAIN";
                debug_counts.MOUNTAIN++;
              } else if (rand < 0.75) {
                terrainType = "PLAIN";
                debug_counts.PLAIN++;
              } else {
                terrainType = "OCEAN";
                debug_counts.OCEAN++;
              }

              mapData.push({
                server_id: serverId,
                x: x,
                y: y,
                terrain_type: terrainType,
              });
            }
          }

          console.log("Generated terrain distribution:", debug_counts);

          // Insert in batches of 1000 to avoid payload size limits
          for (let i = 0; i < mapData.length; i += 1000) {
            const batch = mapData.slice(i, i + 1000);
            const { error } = await supabaseClient
              .from("map_data")
              .insert(batch);

            if (error) {
              console.error("Error inserting batch:", error);
              throw error;
            }
          }

          // Verify the data was inserted correctly
          const { data: verifyData, error: verifyError } = await supabaseClient
            .from("map_data")
            .select("terrain_type")
            .eq("server_id", serverId)
            .limit(5);

          if (verifyError) {
            console.error("Error verifying map data:", verifyError);
          } else {
            console.log("Sample of inserted map data:", verifyData);
          }
        } catch (error) {
          console.error("Error storing map:", error);
          throw error;
        }
      }

      async function initSupabase() {
        try {
          console.log("Initializing Supabase...");

          const {
            data: { session },
            error: sessionError,
          } = await supabaseClient.auth.getSession();
          console.log("Session check:", session, sessionError);

          if (!session) {
            console.log("No session, using magic link...");
            const email = prompt("Enter your email to play:", "");
            if (!email) {
              throw new Error("Email is required to play");
            }

            const { data, error } = await supabaseClient.auth.signInWithOtp({
              email: email,
              options: {
                emailRedirectTo: window.location.href,
              },
            });

            if (error) {
              console.error("Sign in error:", error);
              throw error;
            }

            alert("Check your email for the login link!");
            console.log("Magic link sent:", data);
            return;
          }

          const {
            data: { user },
            error: userError,
          } = await supabaseClient.auth.getUser();
          if (userError) {
            console.error("Get user error:", userError);
            throw userError;
          }

          gameState.playerId = user.id;
          console.log("Player ID set:", gameState.playerId);

          // Load player position before creating/updating player record
          const { data: positionData, error: positionError } =
            await supabaseClient
              .from("player_positions")
              .select("x, y")
              .eq("player_id", gameState.playerId)
              .single();

          if (positionError && positionError.code !== "PGRST116") {
            // PGRST116 is "no rows returned"
            console.error("Position fetch error:", positionError);
            throw positionError;
          }

          // Set position from database or use default
          gameState.playerPos = positionData || { x: 60, y: 60 };
          console.log(
            "Initial position set from database:",
            gameState.playerPos
          );

          // Create player record if it doesn't exist
          console.log("Creating player record...");
          const { error: playerError } = await supabaseClient
            .from("players")
            .upsert({
              id: gameState.playerId,
              username: user.email.split("@")[0], // Use part before @ as username
              created_at: new Date().toISOString(), // Add created_at timestamp
            });

          if (playerError) {
            console.error("Player creation error:", playerError);
            throw playerError;
          }

          // Add a small delay to ensure the player record is created
          await new Promise((resolve) => setTimeout(resolve, 1000));

          console.log("Player record created successfully");

          // Subscribe to player position changes
          const channel = supabaseClient
            .channel("player_positions")
            .on(
              "postgres_changes",
              {
                event: "*",
                schema: "public",
                table: "player_positions",
              },
              (payload) => {
                if (
                  payload.new &&
                  payload.new.player_id !== gameState.playerId
                ) {
                  gameState.otherPlayers.set(payload.new.player_id, {
                    x: payload.new.x,
                    y: payload.new.y,
                  });
                  renderMap();
                }
              }
            )
            .subscribe();

          console.log("Channel subscribed");

          // Insert initial player position
          const { data: posData, error: posError } = await supabaseClient
            .from("player_positions")
            .upsert({
              player_id: gameState.playerId,
              x: gameState.playerPos.x,
              y: gameState.playerPos.y,
            });

          if (posError) {
            console.error("Position update error:", posError);
            throw posError;
          }
          console.log("Initial position set:", posData);

          // Also fetch initial positions of other players
          const { data: otherPositions, error: otherPositionsError } =
            await supabaseClient
              .from("player_positions")
              .select("*")
              .neq("player_id", gameState.playerId);

          if (!otherPositionsError && otherPositions) {
            otherPositions.forEach((pos) => {
              gameState.otherPlayers.set(pos.player_id, {
                x: pos.x,
                y: pos.y,
              });
            });
            console.log("Loaded other players:", gameState.otherPlayers);
          }
        } catch (error) {
          console.error("Error initializing Supabase:", error);
        }
      }

      function renderMap() {
        const canvas = document.getElementById("map-canvas");
        const ctx = canvas.getContext("2d");
        const cellSize = Math.min(window.innerWidth, window.innerHeight) * 0.04;

        // Reset any transformations
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // Set canvas size
        canvas.width = MAP_SIZE * cellSize;
        canvas.height = MAP_SIZE * cellSize;

        // Clear canvas with a background color
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw terrain
        for (let y = 0; y < MAP_SIZE; y++) {
          for (let x = 0; x < MAP_SIZE; x++) {
            const terrain = gameState.map[y][x];

            if (!terrain || !terrain.emoji) continue;

            // Calculate position
            const posX = x * cellSize + cellSize / 2;
            const posY = y * cellSize + cellSize / 2;

            // Set text properties for each emoji
            ctx.font = `${cellSize * 0.6}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "white";

            // Draw the emoji
            ctx.fillText(terrain.emoji, posX, posY);
          }
        }

        // Draw other players
        ctx.font = `${cellSize * 0.6}px Arial`;
        gameState.otherPlayers.forEach((pos) => {
          ctx.fillText(
            "ü¶ä",
            pos.x * cellSize + cellSize / 2,
            pos.y * cellSize + cellSize / 2
          );
        });

        // Draw main player
        if (gameState.playerPos) {
          ctx.fillText(
            "üêª",
            gameState.playerPos.x * cellSize + cellSize / 2,
            gameState.playerPos.y * cellSize + cellSize / 2
          );
        }

        // Apply viewport transform to canvas style
        canvas.style.transform = `translate(${gameState.viewport.x}px, ${gameState.viewport.y}px) scale(${gameState.viewport.scale})`;
      }

      // Also add this debug function
      function debugMapSection(startX = 0, startY = 0, size = 5) {
        console.log(
          `Debugging map section from (${startX},${startY}) to (${
            startX + size - 1
          },${startY + size - 1}):`
        );
        for (let y = startY; y < startY + size; y++) {
          let row = "";
          for (let x = startX; x < startX + size; x++) {
            if (gameState.map[y] && gameState.map[y][x]) {
              row += gameState.map[y][x].emoji + " ";
            } else {
              row += "‚ùå ";
            }
          }
          console.log(row);
        }
      }

      // Call this after loadMap completes
      function verifyMapRendering() {
        console.log("Verifying map rendering...");
        debugMapSection(0, 0, 5); // Check top-left corner
        debugMapSection(57, 57, 5); // Check middle section
        debugMapSection(115, 115, 5); // Check bottom-right corner
      }

      function initCanvas() {
        const canvas = document.getElementById("map-canvas");
        const cellSize = Math.min(window.innerWidth, window.innerHeight) * 0.04;

        canvas.width = MAP_SIZE * cellSize;
        canvas.height = MAP_SIZE * cellSize;
      }

      function updateStatus() {
        document.getElementById("health").textContent = gameState.health;
        document.getElementById("score").textContent = gameState.score;
        if (gameState.playerPos) {
          document.getElementById("position-x").textContent =
            gameState.playerPos.x;
          document.getElementById("position-y").textContent =
            gameState.playerPos.y;
        }
      }

      function checkEncounter() {
        const currentTerrain =
          gameState.map[gameState.playerPos.y][gameState.playerPos.x];
        const terrainType = Object.keys(TERRAIN_TYPES).find(
          (type) => TERRAIN_TYPES[type].emoji === currentTerrain.emoji
        );

        const encounterRate =
          gameState.configs?.encounter_rates?.[terrainType] ?? 0.3;

        if (Math.random() < encounterRate) {
          gameState.inBattle = true;
          gameState.currentEnemy = currentTerrain.encounter;
          showBattleScreen();
        }
      }

      function showBattleScreen() {
        document.getElementById("battle-screen").style.display = "block";
        document.getElementById(
          "battle-text"
        ).innerHTML = `A wild ${gameState.currentEnemy} appeared!`;
        document.getElementById("battle-options").style.display = "block";
        document.getElementById("attack-options").style.display = "none";
      }

      function chooseBattle(choice) {
        if (choice === "fight") {
          document.getElementById("battle-options").style.display = "none";
          document.getElementById("attack-options").style.display = "block";
          document.getElementById("battle-text").innerHTML =
            "Choose your attack!";
        } else {
          if (Math.random() < 0.6) {
            endBattle();
            document.getElementById("battle-text").innerHTML =
              "Got away safely!";
          } else {
            gameState.health -= 10;
            updateStatus();
            document.getElementById("battle-text").innerHTML =
              "Couldn't escape! Lost 10 health!";
            if (gameState.health <= 0) {
              gameOver();
            }
          }
        }
      }

      function chooseAttack(playerChoice) {
        const choices = ["quick", "heavy", "block"];
        const enemyChoice = choices[Math.floor(Math.random() * choices.length)];

        let result = "";
        if (
          (playerChoice === "quick" && enemyChoice === "heavy") ||
          (playerChoice === "heavy" && enemyChoice === "block") ||
          (playerChoice === "block" && enemyChoice === "quick")
        ) {
          gameState.playerHits++;
          result = "You hit the enemy!";
        } else if (playerChoice === enemyChoice) {
          result = "Draw!";
        } else {
          gameState.enemyHits++;
          gameState.health -= 10;
          result = "Enemy hit you! -10 health";
        }

        document.getElementById(
          "battle-text"
        ).innerHTML = `Your ${playerChoice} VS Enemy ${enemyChoice}<br>${result}<br>
                Your hits: ${gameState.playerHits} | Enemy hits: ${gameState.enemyHits}`;

        updateStatus();

        if (gameState.playerHits >= 3) {
          gameState.score += 100;
          updateStatus();
          document.getElementById("battle-text").innerHTML +=
            "<br>You won! +100 points";
          setTimeout(endBattle, 1500);
        } else if (gameState.enemyHits >= 3) {
          document.getElementById("battle-text").innerHTML += "<br>You lost!";
          setTimeout(endBattle, 1500);
        }

        if (gameState.health <= 0) {
          gameOver();
        }
      }

      function endBattle() {
        gameState.inBattle = false;
        gameState.currentEnemy = null;
        gameState.playerHits = 0;
        gameState.enemyHits = 0;
        document.getElementById("battle-screen").style.display = "none";
      }

      function gameOver() {
        document.getElementById("game-over").style.display = "flex";
        document.getElementById("final-score").textContent = gameState.score;
      }

      function restartGame() {
        gameState = {
          map: [],
          playerPos: { x: 60, y: 60 },
          health: 100,
          score: 0,
          inBattle: false,
          currentEnemy: null,
          playerHits: 0,
          enemyHits: 0,
          viewport: {
            x: 0,
            y: 0,
            scale: 1,
            isDragging: false,
            lastX: 0,
            lastY: 0,
          },
          playerId: gameState.playerId,
          otherPlayers: new Map(),
          configs: null,
          serverId: null,
        };
        initMap();
        initCanvas();
        renderMap();
        updateStatus();
        document.getElementById("game-over").style.display = "none";
        document.getElementById("battle-screen").style.display = "none";
      }

      // Pan handling
      const gameMap = document.getElementById("game-map");

      gameMap.addEventListener("mousedown", (e) => {
        if (gameState.inBattle) return;
        gameState.viewport.isDragging = true;
        gameState.viewport.lastX = e.clientX;
        gameState.viewport.lastY = e.clientY;
        gameMap.style.cursor = "grabbing";
      });

      gameMap.addEventListener("mousemove", (e) => {
        if (!gameState.viewport.isDragging) return;

        const dx = e.clientX - gameState.viewport.lastX;
        const dy = e.clientY - gameState.viewport.lastY;

        gameState.viewport.x += dx;
        gameState.viewport.y += dy;

        gameState.viewport.lastX = e.clientX;
        gameState.viewport.lastY = e.clientY;

        renderMap();
      });

      gameMap.addEventListener("mouseup", () => {
        gameState.viewport.isDragging = false;
        gameMap.style.cursor = "grab";
      });

      gameMap.addEventListener("mouseleave", () => {
        gameState.viewport.isDragging = false;
        gameMap.style.cursor = "grab";
      });

      document.addEventListener("keydown", async (e) => {
        if (gameState.inBattle) return;

        const newPos = { ...gameState.playerPos };

        switch (e.key) {
          case "ArrowUp":
            if (newPos.y > 0) newPos.y--;
            break;
          case "ArrowDown":
            if (newPos.y < MAP_SIZE - 1) newPos.y++;
            break;
          case "ArrowLeft":
            if (newPos.x > 0) newPos.x--;
            break;
          case "ArrowRight":
            if (newPos.x < MAP_SIZE - 1) newPos.x++;
            break;
          default:
            return;
        }

        gameState.playerPos = newPos;

        // Update position in Supabase
        try {
          const { error } = await supabaseClient
            .from("player_positions")
            .upsert({
              player_id: gameState.playerId,
              x: newPos.x,
              y: newPos.y,
            });

          if (error) {
            console.error("Position update error:", error);
            throw error;
          }
        } catch (error) {
          console.error("Error updating position:", error);
        }

        renderMap();
        updateStatus();
        checkEncounter();
      });

      // Simplify initGame since position loading is now handled in initSupabase
      async function initGame() {
        try {
          await initSupabase();
          await fetchGameConfigs();

          // Find or create server and load map
          const serverId = await findOrCreateServer();
          await loadMap(serverId);

          initCanvas();
          renderMap();
          updateStatus();
          startLastActiveUpdates();
        } catch (error) {
          console.error("Error initializing game:", error);
        }
      }

      // Replace the initialization calls with:
      initGame();

      // Add window resize handler
      window.addEventListener("resize", () => {
        initCanvas();
        renderMap();
      });

      // Add cleanup function for when player leaves
      async function leaveServer() {
        if (!gameState.serverId) return;

        if (lastActiveInterval) {
          clearInterval(lastActiveInterval);
        }

        try {
          // Get current session
          const {
            data: { session },
          } = await supabaseClient.auth.getSession();
          if (!session) {
            console.error("No active session");
            return;
          }

          // Use fetch with keepalive to ensure the request completes
          const response = await fetch(
            `${getEnvVariable(
              "NEXT_PUBLIC_SUPABASE_URL"
            )}/rest/v1/rpc/decrement_server_players`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                apikey: getEnvVariable("NEXT_PUBLIC_SUPABASE_ANON_KEY"),
                Authorization: `Bearer ${session.access_token}`,
              },
              body: JSON.stringify({ server_id: gameState.serverId }),
              keepalive: true,
            }
          );

          // Remove player from server_players table
          await fetch(
            `${getEnvVariable(
              "NEXT_PUBLIC_SUPABASE_URL"
            )}/rest/v1/server_players`,
            {
              method: "DELETE",
              headers: {
                "Content-Type": "application/json",
                apikey: getEnvVariable("NEXT_PUBLIC_SUPABASE_ANON_KEY"),
                Authorization: `Bearer ${session.access_token}`,
                Prefer: "return=minimal",
              },
              body: JSON.stringify({
                server_id: gameState.serverId,
                player_id: gameState.playerId,
              }),
              keepalive: true,
            }
          );
        } catch (error) {
          console.error("Error leaving server:", error);
        }
      }

      // Modify the beforeunload event listener
      window.addEventListener("beforeunload", (event) => {
        // Cancel the event
        event.preventDefault();
        // Chrome requires returnValue to be set
        event.returnValue = "";

        // Synchronously start the cleanup
        leaveServer();
      });

      // Also add cleanup on page hide
      window.addEventListener("pagehide", leaveServer);

      // Add cleanup on visibility change to hidden
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          leaveServer();
        }
      });

      // Also let's verify our TERRAIN_TYPES constant is correct
      console.log("Available terrain types:", Object.keys(TERRAIN_TYPES));
    </script>
  </body>
</html>
